{"version":3,"sources":["widgets/Sticky.tsx","types.ts","widgets/Arrow.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleContextMenu","e","props","onContextMenu","onRightClick","widget","id","handleDragStart","onDragStart","this","cursor","selected","x","y","width","height","onMouseDown","style","top","left","border","className","React","Component","stickyFactory","spec","uuid","type","arrowFactory","start","end","points","arrowType","chartBranchSide","chartBranchPosition","Arrow","position","pointerEvents","xmlns","version","isHorizontalConnection","d","stroke","strokeWidth","fill","cx","cy","r","midDistance","segment2Position","p1","p2","p3","p4","d1","d2","d3","pathGenerator","PureComponent","App","ref","state","initialId","lastX","lastY","widgets","handleRightClick","preventDefault","stopPropagation","cancelArrowCreation","handleStickyRightClick","setState","prevState","startWidget","endWidget","arrow","relation","Math","abs","updateArrowChartBranch","handleDoubleClick","s","clientX","clientY","handleDrag","dragged","connectedArrows","Object","values","filter","w","reduce","acc","cur","updateArrow","button","handleKeyDown","key","prevWidgets","forEach","handleMouseDown","handleMouseUp","map","handleRef","ignoreLoneSide","chartBranchArrow","find","connectedArrow","console","log","draggingWidgetId","draggedWidget","startPoint","endPoint","tabIndex","onDoubleClick","onKeyDown","onMouseMove","onMouseUp","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.26023d55.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onRightClick: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDragStart: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  selected: boolean;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.Component<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onRightClick: onContextMenu, widget } = this.props;\n\n    onContextMenu(widget.id, e);\n  };\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onDragStart, widget } = this.props;\n\n    onDragStart(widget.id, e);\n  };\n\n  render() {\n    const {\n      cursor,\n      selected,\n      widget: { x, y , width, height},\n    } = this.props;\n    return (\n      <div\n        onContextMenu={this.handleContextMenu}\n        onMouseDown={this.handleDragStart}\n        style={{\n          top: y,\n          left: x,\n          width: width,\n          height: height,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n          border: selected ? \"2px solid blue\" : \"none\",\n        }}\n        className=\"Sticky\"\n      />\n    );\n  }\n}\n\nexport default Sticky;\n","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type: PointType;\n}\n\n// initial: initial simple arrow, centered to the connected widgets on both ends, bent into 3 segments having the same length in both parallel segments.\n// chartBranch: created from an 'initial' arrow, centered to the connected widgets on both ends, bent into 3 segments, can share inital segment with other 'chartBranch' arrows, 1st segment size stays put.\n// chartSide: created from an 'initial' arrow, moved to the side of a group of 'chartBranch' arrows and can be on any point of both connected widgets.\nexport type ArrowType = \"initial\" | \"chartBranch\" | \"chartSide\";\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  end: string | null;\n  arrowType: ArrowType;\n  chartBranchSide: PointType | null;\n  chartBranchPosition: number | null;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: 100,\n  width: 100,\n  type: \"sticky\",\n  x: (spec.x || 0) - 50,\n  y: (spec.y || 0) - 50,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n  arrowType: \"initial\",\n  chartBranchSide: null,\n  chartBranchPosition: null,\n});\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport { ArrowWidget, Point, PointType } from \"../types\";\n\ninterface PropTypes {\n  widget: ArrowWidget;\n}\n\nconst pathGenerator = (points: Point[], chartBranchSide: PointType | null, chartBranchPosition: number | null) => {\n  const start = points[0];\n  const end = points[1];\n  const isHorizontalConnection = start.type === \"right\" || start.type === \"left\";\n\n  // straight line\n  if((isHorizontalConnection && start.y === end.y) ||\n    (!isHorizontalConnection && start.x === end.x)) {\n      const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n      return [\n        <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n        <circle\n          cx={`${end.x}`}\n          cy={`${end.y}`}\n          r=\"5\"\n          stroke=\"#5cb85c\"\n          fill=\"#5cb85c\"\n        ></circle>,\n      ];\n  }\n\n  // 3-segments line\n  const midDistance = isHorizontalConnection ? (end.x - start.x) / 2 : (end.y - start.y) / 2;\n  let segment2Position = isHorizontalConnection ? start.x + midDistance: start.y + midDistance;\n  if(chartBranchSide && chartBranchPosition && chartBranchSide === start.type) {\n    segment2Position = chartBranchPosition;\n  }\n\n  const p1 = `${start.x} ${start.y}`;\n  const p2 = isHorizontalConnection ? `${segment2Position} ${start.y}` : ` ${start.x} ${segment2Position}`;\n  const p3 = isHorizontalConnection ? `${segment2Position} ${end.y}` : ` ${end.x} ${segment2Position}`;\n  const p4 = `${end.x} ${end.y}`;\n\n  const d1 = `M ${p1} L ${p2}`;\n  const d2 = `M ${p2} L ${p3}`;\n  const d3 = `M ${p3} L ${p4}`;\n\n  return [\n    <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <circle\n      cx={`${end.x}`}\n      cy={`${end.y}`}\n      r=\"5\"\n      stroke=\"#5cb85c\"\n      fill=\"#5cb85c\"\n    ></circle>,\n  ];\n};\n\nclass Arrow extends React.PureComponent<PropTypes> {\n  render() {\n    return (\n      <svg\n        style={{ position: \"absolute\", top: 0, left: 0, pointerEvents: \"none\" }}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        version=\"1.1\"\n      >\n        {pathGenerator(this.props.widget.points, this.props.widget.chartBranchSide, this.props.widget.chartBranchPosition)}\n      </svg>\n    );\n  }\n}\n\nexport default Arrow;\n","import React from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n} from \"./types\";\nimport Arrow from \"./widgets/Arrow\";\n\nexport const TOLERANCE = 10;\n\ninterface State {\n  cursor: React.CSSProperties[\"cursor\"];\n  dragging: string | null;\n  initialId: string | null;\n  initialX: number | null;\n  initialY: number | null;\n  lastX: number | null;\n  lastY: number | null;\n  selected: string | null;\n  widgets: Record<string, Widget>;\n}\n\nclass App extends React.Component<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    cursor: \"auto\",\n    dragging: null,\n    initialId: null,\n    initialX: null,\n    initialY: null,\n    lastX: null,\n    lastY: null,\n    selected: null,\n    widgets: {},\n  };\n\n  cancelArrowCreation() {\n      this.setState({\n        initialId: null,\n        cursor: \"auto\",\n      });\n  }\n  \n  handleRightClick = (e: React.MouseEvent<HTMLDivElement>) => { \n    e.preventDefault();\n    e.stopPropagation();\n\n    if (this.state.initialId) {\n      this.cancelArrowCreation();\n    }\n  }\n\n  handleStickyRightClick = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    // start arrow creation\n    if (!this.state.initialId) {\n      this.setState({\n        initialId: id,\n        cursor: \"crosshair\",\n      });\n      return;\n    }\n\n    if (this.state.initialId === id) {\n      this.cancelArrowCreation();\n      return;\n    }\n\n    this.setState((prevState) => {\n      const startWidget = prevState.widgets[prevState.initialId || \"\"];\n      const endWidget = prevState.widgets[id];\n      const points: Point[] = [];\n      const arrow = {\n        ...arrowFactory({ start: prevState.initialId, end: id }),\n        points,\n      };\n      // relation > 1 horizontal line\n      const relation = Math.abs(\n        (startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)\n      );\n\n      if (startWidget.x + startWidget.width + TOLERANCE < endWidget.x) {\n        if (relation > 1) {\n          points[0] = {\n            x: startWidget.x + startWidget.width,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"right\",\n          };\n          points[1] = {\n            x: endWidget.x,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"left\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      } else {\n        if (relation > 1) {\n          points[0] = {\n            x: startWidget.x,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"left\",\n          };\n          points[1] = {\n            x: endWidget.x + endWidget.width,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"right\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      }\n      \n      this.updateArrowChartBranch(arrow, prevState.widgets, true);\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        initialId: null,\n        widgets: {\n          ...prevState.widgets,\n          [arrow.id]: arrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    const s = stickyFactory({ x: e.clientX, y: e.clientY });\n    this.setState((prevState) => ({\n      selected: s.id,\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX, clientY } = e;\n    this.setState((prevState) => {\n      if (!prevState.dragging || !prevState.lastX || !prevState.lastY)\n        return { ...prevState };\n      const dragged = {\n        ...prevState.widgets[prevState.dragging],\n      } as StickyWidget;\n\n      dragged.x = dragged.x + clientX - prevState.lastX;\n      dragged.y = dragged.y + clientY - prevState.lastY;\n\n      const connectedArrows = Object.values(prevState.widgets)\n        .filter(\n          (w) =>\n            w.type === \"arrow\" &&\n            (w.start === prevState.dragging || w.end === prevState.dragging)\n        )\n        .reduce((acc, cur) => {\n          const arrow = cur as ArrowWidget;\n          this.updateArrow(arrow, prevState.widgets, prevState.dragging, dragged);\n\n          this.updateArrowChartBranch(arrow, prevState.widgets, true);\n\n          return {\n            ...acc,\n            [arrow.id]: {\n              ...arrow,\n            },\n          };\n        }, {} as Record<string, Widget>);\n\n      return {\n        lastX: clientX,\n        lastY: clientY,\n        widgets: {\n          ...prevState.widgets,\n          [dragged.id]: dragged,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleDragStart = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX: initialX, clientY: initialY } = e;\n    e.stopPropagation();\n\n    if (e.button !== 0) return;\n\n    this.setState({\n      dragging: id,\n      selected: id,\n      initialX: initialX,\n      initialY: initialY,\n      lastX: initialX,\n      lastY: initialY,\n    });\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if ((e.key === \"Backspace\" || e.key === \"Delete\") && this.state.selected) {\n      this.setState((prevState) => {\n        const id = prevState.selected || \"\";\n        const prevWidgets = prevState.widgets;\n        delete prevWidgets[id];\n\n        Object.values(prevWidgets).forEach((w) => {\n          if (w.type === \"arrow\" && (w.start === id || w.end === id))\n            delete prevWidgets[w.id];\n        });\n        return {\n          ...prevState,\n          selected: null,\n          widgets: { ...prevWidgets },\n        };\n      });\n    }\n  };\n\n  handleMouseDown = () => {\n    this.setState({ selected: null });\n  };\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    this.setState((prevState) => {\n      \n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      const connectedArrows = Object.values(prevState.widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          (w.start === prevState.dragging || w.end === prevState.dragging)\n      ).map(w=> w as ArrowWidget)\n      .reduce((acc, arrow) => {\n        \n        if(arrow.end === prevState.dragging) {\n          this.updateArrowChartBranch(arrow, prevState.widgets, false);\n        }\n\n        return {\n          ...acc,\n          [arrow.id]: {\n            ...arrow,\n          },\n        };\n      }, {} as Record<string, Widget>);\n      \n      return {\n        dragging: null,\n        widgets: {\n          ...prevState.widgets,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleRef = (ref: HTMLDivElement) => (this.ref = ref);\n\n  updateArrowChartBranch(arrow: ArrowWidget, widgets: Record<string, Widget>, ignoreLoneSide: boolean) {\n    if(arrow.arrowType === \"chartSide\") return;\n\n    // don't recalculate if chartSide didn't change\n    if(!arrow.chartBranchSide || arrow.chartBranchSide !== arrow.points[0].type) {\n\n      // all arrows connected to \"start\" widget\n      const originArrows = Object.values(widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          (w.start === arrow.start)\n      ).map(w=> w as ArrowWidget);\n      \n      // find another arrow that share same origin point and already has chartBranchPosition fixed\n      const chartBranchArrow = originArrows.find(connectedArrow =>\n        connectedArrow !== arrow &&\n        connectedArrow.arrowType === \"chartBranch\" &&\n        connectedArrow.points[0].type === arrow.points[0].type &&\n        connectedArrow.chartBranchPosition);\n\n      // don't force chartBranching while dragging on a new side of the origin widget\n      if(ignoreLoneSide && !chartBranchArrow) return;\n        \n      console.log(`updateArrowChartBranch originType: ${arrow.points[0].type} chartBranchArrow: ${chartBranchArrow}  chartBranchPosition: ${chartBranchArrow?.chartBranchPosition}`)\n      arrow.arrowType = \"chartBranch\";\n      arrow.chartBranchSide = arrow.points[0].type;\n      if(chartBranchArrow) {\n        arrow.chartBranchPosition = chartBranchArrow.chartBranchPosition;\n      } else {\n        // fix 2nd segment position to X or Y depending on orientation of the arrow\n        if(arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\") {\n          arrow.chartBranchPosition = arrow.points[0].x + ((arrow.points[1].x - arrow.points[0].x) / 2);\n        } else {\n          arrow.chartBranchPosition = arrow.points[0].y + ((arrow.points[1].y - arrow.points[0].y) / 2);\n        }\n      }\n    }\n  }\n  \n  // updates arrow points (start/end), both position and type\n  updateArrow(arrow: ArrowWidget, widgets: Record<string, Widget>, draggingWidgetId: string | null, draggedWidget: StickyWidget) {\n    const startPoint = arrow.points[0];\n    const endPoint = arrow.points[1];\n\n    if (arrow.end === draggingWidgetId) {\n      const startWidget = widgets[\n        arrow.start || \"\"\n      ] as StickyWidget;\n\n      if (startPoint.type === \"right\") {\n        // If the start.x + tolerance is lower than end.x, we keep things\n        // as they are\n        if (startPoint.x + TOLERANCE < endPoint.x) {\n          arrow.points[1] = {\n            type: \"left\",\n            x: draggedWidget.x,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n          // Else, we check which point is higher so we can switch our point\n          // types and re-order the connections\n        } else if (startPoint.y + TOLERANCE < endPoint.y) {\n          arrow.points[0] = {\n            type: \"bottom\",\n            x: startWidget.x + startWidget.width / 2,\n            y: startWidget.y + startWidget.height,\n          };\n          arrow.points[1] = {\n            type: \"top\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y,\n          };\n          // Final else, it's the only remaining option\n        } else {\n          arrow.points[0] = {\n            type: \"top\",\n            x: startWidget.x + startWidget.width / 2,\n            y: startWidget.y,\n          };\n          arrow.points[1] = {\n            type: \"bottom\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y + draggedWidget.height,\n          };\n        }\n      }\n\n      if (startPoint.type === \"left\") {\n        // If the start.x + tolerance is lower than end.x, we keep things\n        // as they are\n        if (startPoint.x - TOLERANCE < endPoint.x) {\n          arrow.points[1] = {\n            type: \"right\",\n            x: draggedWidget.x + draggedWidget.width,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n          // Else, we check which point is higher so we can swith our point\n          // types and re-order the connections\n        } else if (startPoint.y + TOLERANCE < endPoint.y) {\n          arrow.points[0] = {\n            type: \"bottom\",\n            x: startWidget.x + startWidget.width / 2,\n            y: startWidget.y + startWidget.height,\n          };\n          arrow.points[1] = {\n            type: \"top\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y,\n          };\n          // Final else, it's the only remaining option\n        } else {\n          arrow.points[0] = {\n            type: \"top\",\n            x: startWidget.x + startWidget.width / 2,\n            y: startWidget.y,\n          };\n          arrow.points[1] = {\n            type: \"bottom\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y + draggedWidget.height,\n          };\n        }\n      }\n\n      // If start point is bottom, it means endpoint is top, trust me.\n      if (startPoint.type === \"bottom\") {\n        // If the start.y + tolerance is lower than end.y, we keep things\n        // as they are\n        if (startPoint.y + TOLERANCE < endPoint.y) {\n          arrow.points[1] = {\n            type: \"top\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y,\n          };\n          // Else, we check if the start point is \"lefter\" than the end\n          // point\n        } else if (startPoint.x + TOLERANCE < endPoint.x) {\n          arrow.points[0] = {\n            type: \"right\",\n            x: startWidget.x + startWidget.width,\n            y: startWidget.y + startWidget.height / 2,\n          };\n          arrow.points[1] = {\n            type: \"left\",\n            x: draggedWidget.x,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n          // Finally, we know the start point is \"righter\" than the end one\n        } else {\n          arrow.points[0] = {\n            type: \"left\",\n            x: startWidget.x,\n            y: startWidget.y + startWidget.width / 2,\n          };\n          arrow.points[1] = {\n            type: \"right\",\n            x: draggedWidget.x + draggedWidget.width,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n        }\n      }\n\n      if (startPoint.type === \"top\") {\n        // If the start.y + tolerance is lower than end.y, we keep things\n        // as they are\n        if (startPoint.y - TOLERANCE > endPoint.y) {\n          arrow.points[1] = {\n            type: \"bottom\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y + draggedWidget.height,\n          };\n          // Else, we check if the start point is \"lefter\" than the end\n          // point\n        } else if (startPoint.x + TOLERANCE < endPoint.x) {\n          arrow.points[0] = {\n            type: \"right\",\n            x: startWidget.x + startWidget.width,\n            y: startWidget.y + startWidget.height / 2,\n          };\n          arrow.points[1] = {\n            type: \"left\",\n            x: draggedWidget.x,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n          // Finally, we know the start point is \"righter\" than the end one\n        } else {\n          arrow.points[0] = {\n            type: \"left\",\n            x: startWidget.x,\n            y: startWidget.y + startWidget.width / 2,\n          };\n          arrow.points[1] = {\n            type: \"right\",\n            x: draggedWidget.x + draggedWidget.width,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n        }\n      }\n    }\n\n    if (arrow.start === draggingWidgetId) {\n      const endWidget = widgets[\n        arrow.end || \"\"\n      ] as StickyWidget;\n\n      if (startPoint.type === \"right\") {\n        // If the start.x + tolerance is lower than end.x, we keep things\n        // as they are\n        if (startPoint.x + TOLERANCE < endPoint.x) {\n          arrow.points[0] = {\n            type: \"right\",\n            x: draggedWidget.x + draggedWidget.width,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n          // Else, we check which point is higher so we can swith our point\n          // types and re-order the connections\n        } else if (startPoint.y + TOLERANCE < endPoint.y) {\n          arrow.points[0] = {\n            type: \"bottom\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y + draggedWidget.height,\n          };\n          arrow.points[1] = {\n            type: \"top\",\n            x: endWidget.x + endWidget.width / 2,\n            y: endWidget.y,\n          };\n          // Final else, it's the only remaining option\n        } else {\n          arrow.points[0] = {\n            type: \"top\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y,\n          };\n          arrow.points[1] = {\n            type: \"bottom\",\n            x: endWidget.x + endWidget.width / 2,\n            y: endWidget.y + endWidget.height,\n          };\n        }\n      }\n\n      if (startPoint.type === \"left\") {\n        // If the start.x + tolerance is lower than end.x, we keep things\n        // as they are\n        if (startPoint.x - TOLERANCE > endPoint.x) {\n          arrow.points[0] = {\n            type: \"left\",\n            x: draggedWidget.x,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n          // Else, we check which point is higher so we can switch our point\n          // types and re-order the connections\n        } else if (startPoint.y + TOLERANCE < endPoint.y) {\n          arrow.points[0] = {\n            type: \"bottom\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y + draggedWidget.height,\n          };\n          arrow.points[1] = {\n            type: \"top\",\n            x: endWidget.x + endWidget.width / 2,\n            y: endWidget.y,\n          };\n          // Final else, it's the only remaining option\n        } else {\n          arrow.points[0] = {\n            type: \"top\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y,\n          };\n          arrow.points[1] = {\n            type: \"bottom\",\n            x: endWidget.x + endWidget.width / 2,\n            y: endWidget.y + endWidget.height,\n          };\n        }\n      }\n\n      // If start point is bottom, it means endpoint is top, trust me.\n      if (startPoint.type === \"bottom\") {\n        // If the start.y + tolerance is lower than end.y, we keep things\n        // as they are\n        if (startPoint.y + TOLERANCE < endPoint.y) {\n          arrow.points[0] = {\n            type: \"bottom\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y + draggedWidget.height,\n          };\n          // Else, we check if the start point is \"lefter\" than the end\n          // point\n        } else if (startPoint.x + TOLERANCE < endPoint.x) {\n          arrow.points[0] = {\n            type: \"right\",\n            x: draggedWidget.x + draggedWidget.width,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n          arrow.points[1] = {\n            type: \"left\",\n            x: endWidget.x,\n            y: endWidget.y + endWidget.height / 2,\n          };\n          // Finally, we know the start point is \"righter\" than the end one\n        } else {\n          arrow.points[0] = {\n            type: \"left\",\n            x: draggedWidget.x,\n            y: draggedWidget.y + draggedWidget.width / 2,\n          };\n          arrow.points[1] = {\n            type: \"right\",\n            x: endWidget.x + endWidget.width,\n            y: endWidget.y + endWidget.height / 2,\n          };\n        }\n      }\n\n      if (startPoint.type === \"top\") {\n        // If the start.y + tolerance is lower than end.y, we keep things\n        // as they are\n        if (startPoint.y - TOLERANCE > endPoint.y) {\n          arrow.points[0] = {\n            type: \"top\",\n            x: draggedWidget.x + draggedWidget.width / 2,\n            y: draggedWidget.y,\n          };\n          // Else, we check if the start point is \"lefter\" than the end\n          // point\n        } else if (startPoint.x + TOLERANCE < endPoint.x) {\n          arrow.points[0] = {\n            type: \"right\",\n            x: draggedWidget.x + draggedWidget.width,\n            y: draggedWidget.y + draggedWidget.height / 2,\n          };\n          arrow.points[1] = {\n            type: \"left\",\n            x: endWidget.x,\n            y: endWidget.y + endWidget.height / 2,\n          };\n          // Finally, we know the start point is \"righter\" than the end one\n        } else {\n          arrow.points[0] = {\n            type: \"left\",\n            x: draggedWidget.x,\n            y: draggedWidget.y + draggedWidget.width / 2,\n          };\n          arrow.points[1] = {\n            type: \"right\",\n            x: endWidget.x + endWidget.width,\n            y: endWidget.y + endWidget.height / 2,\n          };\n        }\n      }\n    }\n  }\n\n  render() {\n    const { cursor, selected, widgets } = this.state;\n    return (\n      <div\n        style={{ cursor }}\n        className=\"App\"\n        tabIndex={1}\n        onContextMenu={this.handleRightClick}\n        onDoubleClick={this.handleDoubleClick}\n        onKeyDown={this.handleKeyDown}\n        onMouseMove={this.handleDrag}\n        onMouseDown={this.handleMouseDown}\n        onMouseUp={this.handleMouseUp}\n        ref={this.handleRef}\n      >\n        {Object.values(widgets).map((w) => {\n          if (w.type === \"sticky\") {\n            return (\n              <Sticky\n                cursor={cursor}\n                onRightClick={this.handleStickyRightClick}\n                onDragStart={this.handleDragStart}\n                selected={selected === w.id}\n                widget={w}\n                key={w.id}\n              />\n            );\n          }\n\n          if (w.type === \"arrow\") {\n            return <Arrow widget={w} key={w.id} />;\n          }\n\n          return null;\n        })}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}