{"version":3,"sources":["widgets/Sticky.tsx","types.ts","widgets/Arrow.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleContextMenu","e","props","onContextMenu","onRightClick","widget","id","handleDragStart","onDragStart","this","cursor","selected","x","y","width","height","onMouseDown","style","top","left","border","className","React","Component","stickyFactory","spec","uuid","type","arrowFactory","start","end","points","arrowType","chartBranch","initialIsHorizontal","toOrientation","Arrow","position","pointerEvents","xmlns","version","isHorizontalStart","isHorizontalEnd","d","stroke","strokeWidth","fill","cx","cy","r","p1","p2","p3","d1","d2","midDistance","segment2Position","convergenceTarget","convergenceSide","p4","d3","pathGenerator","PureComponent","App","ref","state","initialId","lastX","lastY","widgets","handleRightClick","preventDefault","stopPropagation","cancelArrowCreation","handleStickyRightClick","setState","prevState","startWidget","endWidget","isHorizontalConnection","Math","abs","arrow","updateArrow","handleDoubleClick","s","clientX","clientY","handleDrag","dragged","connectedArrows","Object","values","filter","w","reduce","acc","cur","button","handleKeyDown","key","prevWidgets","forEach","handleMouseDown","handleMouseUp","map","isChartSideArrow","updateArrowChartSide","setArrowChartBranch","handleRef","chartBranchArrow","getSharedChartBranchArrow","assign","chartBranchArrows","length","getWidgetSideMidPosition","convergencePoint","nonConvergencePoint","convergentWidget","nonConvergentWidget","middleX","getIntersectionMiddle","middleY","startWidgetCenter","endWidgetCenter","distX","distY","distXToCenter","max","distYToCenter","a","b","distance","horizontal","aCenter","bCenter","min1","size1","min2","size2","max1","max2","intersection","ARROW_MARGIN","point","newPoint","tabIndex","onDoubleClick","onKeyDown","onMouseMove","onMouseUp","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.a0fae97a.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onRightClick: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDragStart: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  selected: boolean;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.Component<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onRightClick: onContextMenu, widget } = this.props;\n\n    onContextMenu(widget.id, e);\n  };\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onDragStart, widget } = this.props;\n\n    onDragStart(widget.id, e);\n  };\n\n  render() {\n    const {\n      cursor,\n      selected,\n      widget: { x, y , width, height},\n    } = this.props;\n    return (\n      <div\n        onContextMenu={this.handleContextMenu}\n        onMouseDown={this.handleDragStart}\n        style={{\n          top: y,\n          left: x,\n          width: width,\n          height: height,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n          border: selected ? \"2px solid blue\" : \"none\",\n        }}\n        className=\"Sticky\"\n      />\n    );\n  }\n}\n\nexport default Sticky;\n","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\nexport type Orientation = \"horizontal\" | \"vertical\";\nexport type ChartBranchType = \"oneToOne\" | \"oneToMany\" | \"manyToOne\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type: PointType;\n}\n\nexport interface ChartBranch {\n  position: number; // fixed position where arrows share the 2nd branch segment\n  convergenceSide: PointType;  // side of the widget where the arrows converge (might be start or end widget depending of ChartBranchType)\n  type: ChartBranchType;\n}\n\n// initial: initial simple arrow, centered to the connected widgets on both ends, bent into 3 segments having the same length in both parallel segments.\n// chartBranch: created from an 'initial' arrow, centered to the connected widgets on both ends, bent into 3 segments, can share inital segment with other 'chartBranch' arrows, 1st segment size stays put.\n// chartSide: created from an 'initial' arrow, moved to the side of a group of 'chartBranch' arrows and can be on any point of both connected widgets.\nexport type ArrowType = \"initial\" | \"chartBranch\" | \"chartSide\";\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  end: string | null;\n  arrowType: ArrowType;\n  chartBranch: ChartBranch | null;\n  initialIsHorizontal: boolean;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: 100,\n  width: 100,\n  type: \"sticky\",\n  x: (spec.x || 0) - 50,\n  y: (spec.y || 0) - 50,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n  arrowType: \"initial\",\n  chartBranch: null,\n  initialIsHorizontal: true,\n});\n\nexport const toOrientation = (type: PointType) : Orientation => {\n  return type === \"left\" || type === \"right\" ? \"horizontal\" : \"vertical\";\n}\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport { ArrowWidget, ChartBranch, Point } from \"../types\";\n\ninterface PropTypes {\n  widget: ArrowWidget;\n}\n\nconst pathGenerator = (points: Point[], chartBranch: ChartBranch | null) => {\n  const start = points[0];\n  const end = points[1];\n  const isHorizontalStart = start.type === \"right\" || start.type === \"left\";\n  const isHorizontalEnd = end.type === \"right\" || end.type === \"left\";\n\n  // 1-segment straight line\n  if((isHorizontalStart && start.y === end.y) ||\n    (!isHorizontalStart && start.x === end.x)) {\n      const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n      return [\n        <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n        <circle\n          cx={`${end.x}`}\n          cy={`${end.y}`}\n          r=\"5\"\n          stroke=\"#5cb85c\"\n          fill=\"#5cb85c\"\n        ></circle>,\n      ];\n  }\n\n  // 2-segments line\n  if(isHorizontalStart !== isHorizontalEnd) {\n    const p1 = `${start.x} ${start.y}`;\n    const p2 = isHorizontalStart ? `${end.x} ${start.y}` : `${start.x} ${end.y}`;\n    const p3 = `${end.x} ${end.y}`;\n    \n    const d1 = `M ${p1} L ${p2}`;\n    const d2 = `M ${p2} L ${p3}`;\n    return [\n      <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <circle\n        cx={`${end.x}`}\n        cy={`${end.y}`}\n        r=\"5\"\n        stroke=\"#5cb85c\"\n        fill=\"#5cb85c\"\n      ></circle>,\n    ];\n  }\n\n  // 3-segments line\n  const midDistance = isHorizontalStart ? (end.x - start.x) / 2 : (end.y - start.y) / 2;\n  let segment2Position = isHorizontalStart ? start.x + midDistance: start.y + midDistance;\n  if(chartBranch)\n  {\n    const convergenceTarget = chartBranch.type === \"manyToOne\" ? end : start;\n    if(chartBranch.convergenceSide === convergenceTarget.type) {\n      segment2Position = chartBranch.position;\n    }\n  }\n\n  const p1 = `${start.x} ${start.y}`;\n  const p2 = isHorizontalStart ? `${segment2Position} ${start.y}` : ` ${start.x} ${segment2Position}`;\n  const p3 = isHorizontalStart ? `${segment2Position} ${end.y}` : ` ${end.x} ${segment2Position}`;\n  const p4 = `${end.x} ${end.y}`;\n\n  const d1 = `M ${p1} L ${p2}`;\n  const d2 = `M ${p2} L ${p3}`;\n  const d3 = `M ${p3} L ${p4}`;\n\n  return [\n    <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <circle\n      cx={`${end.x}`}\n      cy={`${end.y}`}\n      r=\"5\"\n      stroke=\"#5cb85c\"\n      fill=\"#5cb85c\"\n    ></circle>,\n  ];\n};\n\nclass Arrow extends React.PureComponent<PropTypes> {\n  render() {\n    return (\n      <svg\n        style={{ position: \"absolute\", top: 0, left: 0, pointerEvents: \"none\" }}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        version=\"1.1\"\n      >\n        {pathGenerator(this.props.widget.points, this.props.widget.chartBranch)}\n      </svg>\n    );\n  }\n}\n\nexport default Arrow;\n","import React from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n  toOrientation,\n  ChartBranch,\n} from \"./types\";\nimport Arrow from \"./widgets/Arrow\";\n\nexport const TOLERANCE = 10;\nexport const ARROW_MARGIN = 10;\nexport const TWO_SEGMENT_ARROW_MIN = 20;\n\ninterface State {\n  cursor: React.CSSProperties[\"cursor\"];\n  dragging: string | null;\n  initialId: string | null;\n  initialX: number | null;\n  initialY: number | null;\n  lastX: number | null;\n  lastY: number | null;\n  selected: string | null;\n  widgets: Record<string, Widget>;\n}\n\nclass App extends React.Component<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    cursor: \"auto\",\n    dragging: null,\n    initialId: null,\n    initialX: null,\n    initialY: null,\n    lastX: null,\n    lastY: null,\n    selected: null,\n    widgets: {},\n  };\n\n  cancelArrowCreation() {\n      this.setState({\n        initialId: null,\n        cursor: \"auto\",\n      });\n  }\n  \n  handleRightClick = (e: React.MouseEvent<HTMLDivElement>) => { \n    e.preventDefault();\n    e.stopPropagation();\n\n    if (this.state.initialId) {\n      this.cancelArrowCreation();\n    }\n  }\n\n  handleStickyRightClick = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    // start arrow creation\n    if (!this.state.initialId) {\n      this.setState({\n        initialId: id,\n        cursor: \"crosshair\",\n      });\n      return;\n    }\n\n    if (this.state.initialId === id) {\n      this.cancelArrowCreation();\n      return;\n    }\n\n    this.setState((prevState) => {\n      // create Arrow\n      const startWidget = prevState.widgets[prevState.initialId || \"\"];\n      const endWidget = prevState.widgets[id];\n      const isHorizontalConnection = Math.abs((startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)) > 1;\n      const arrow = {\n        ...arrowFactory({ start: prevState.initialId, end: id }),\n        initialIsHorizontal: isHorizontalConnection,\n      };\n\n      this.updateArrow(arrow, prevState.widgets);\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        initialId: null,\n        widgets: {\n          ...prevState.widgets,\n          [arrow.id]: arrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    const s = stickyFactory({ x: e.clientX, y: e.clientY });\n    this.setState((prevState) => ({\n      selected: s.id,\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX, clientY } = e;\n    this.setState((prevState) => {\n      if (!prevState.dragging || !prevState.lastX || !prevState.lastY)\n        return { ...prevState };\n      const dragged = {\n        ...prevState.widgets[prevState.dragging],\n      } as StickyWidget;\n\n      dragged.x = dragged.x + clientX - prevState.lastX;\n      dragged.y = dragged.y + clientY - prevState.lastY;\n\n      const connectedArrows = Object.values(prevState.widgets)\n        .filter(\n          (w) =>\n            w.type === \"arrow\" &&\n            (w.start === prevState.dragging || w.end === prevState.dragging)\n        )\n        .reduce((acc, cur) => {\n          const arrow = cur as ArrowWidget;\n          this.updateArrow(arrow, prevState.widgets);\n\n          return {\n            ...acc,\n            [arrow.id]: {\n              ...arrow,\n            },\n          };\n        }, {} as Record<string, Widget>);\n\n      return {\n        lastX: clientX,\n        lastY: clientY,\n        widgets: {\n          ...prevState.widgets,\n          [dragged.id]: dragged,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleDragStart = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX: initialX, clientY: initialY } = e;\n    e.stopPropagation();\n\n    if (e.button !== 0) return;\n\n    this.setState({\n      dragging: id,\n      selected: id,\n      initialX: initialX,\n      initialY: initialY,\n      lastX: initialX,\n      lastY: initialY,\n    });\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if ((e.key === \"Backspace\" || e.key === \"Delete\") && this.state.selected) {\n      this.setState((prevState) => {\n        const id = prevState.selected || \"\";\n        const prevWidgets = prevState.widgets;\n        delete prevWidgets[id];\n\n        Object.values(prevWidgets).forEach((w) => {\n          if (w.type === \"arrow\" && (w.start === id || w.end === id))\n            delete prevWidgets[w.id];\n        });\n        return {\n          ...prevState,\n          selected: null,\n          widgets: { ...prevWidgets },\n        };\n      });\n    }\n  };\n\n  handleMouseDown = () => {\n    this.setState({ selected: null });\n  };\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    this.setState((prevState) => {\n      \n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      const connectedArrows = Object.values(prevState.widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          (w.start === prevState.dragging || w.end === prevState.dragging)\n      ).map(w=> w as ArrowWidget)\n      .reduce((acc, arrow) => {\n\n        // stick to your branch side\n        if(arrow.arrowType !== \"chartBranch\") {\n          if(this.isChartSideArrow(arrow, prevState.widgets)) {\n            const startWidget = prevState.widgets[arrow.start || \"\"] as StickyWidget;\n            const endWidget = prevState.widgets[arrow.end || \"\"] as StickyWidget;\n            if(this.updateArrowChartSide(arrow, startWidget, endWidget)) {\n              arrow.arrowType = \"chartSide\";\n            }\n          }\n          \n          //if(arrow.end === prevState.dragging) {\n            // update chart branches state\n            this.setArrowChartBranch(arrow, prevState.widgets, false);\n          //}\n        }\n          \n        // update initial axis\n        arrow.initialIsHorizontal = arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\";\n\n        return {\n          ...acc,\n          [arrow.id]: {\n            ...arrow,\n          },\n        };\n      }, {} as Record<string, Widget>);\n      \n      return {\n        dragging: null,\n        widgets: {\n          ...prevState.widgets,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleRef = (ref: HTMLDivElement) => (this.ref = ref);\n\n  // finds if this arrow should be a part of a branchChart\n  setArrowChartBranch(arrow: ArrowWidget, widgets: Record<string, Widget>, dragging: boolean) {\n    const chartBranchArrow = this.getSharedChartBranchArrow(arrow, widgets);\n    // don't force chartBranching while dragging on an empty side of the origin/end widget\n    if(dragging && !chartBranchArrow) {\n      return;\n    }\n  \n    // don't set arrowType while dragging (wait until mouseUp)\n    if(!dragging) {\n      arrow.arrowType = \"chartBranch\";\n    }\n    \n    if(chartBranchArrow && chartBranchArrow.chartBranch) {\n      // become part of an existing chartBranch\n      if(chartBranchArrow.chartBranch.type === \"oneToOne\") {\n        // if we are just adding the 2nd arrow to this chartBranch, update type and convergenceSide beforehand\n        if(chartBranchArrow.start === arrow.start ){\n          chartBranchArrow.chartBranch.type = \"oneToMany\";\n          chartBranchArrow.chartBranch.convergenceSide = arrow.points[0].type;\n        } else {\n          chartBranchArrow.chartBranch.type = \"manyToOne\";\n          chartBranchArrow.chartBranch.convergenceSide = arrow.points[1].type;\n        }\n      }\n      arrow.chartBranch = Object.assign({}, chartBranchArrow.chartBranch);\n    } else {\n      // new lonely charBranch arrow\n      let chartBranch: ChartBranch = {\n        position: 0,\n        convergenceSide: arrow.points[0].type,\n        type: \"oneToOne\"\n      };\n      // on new branch, set 2nd segment position to half the distance in X or Y depending on orientation \n      if(toOrientation(chartBranch.convergenceSide) === \"horizontal\") {\n        chartBranch.position = arrow.points[0].x + ((arrow.points[1].x - arrow.points[0].x) / 2);\n      } else {\n        chartBranch.position = arrow.points[0].y + ((arrow.points[1].y - arrow.points[0].y) / 2);\n      }\n      arrow.chartBranch = chartBranch;\n    }\n  }\n\n  // find another arrow that share same origin or end point and already has chartBranch defined\n  getSharedChartBranchArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    const chartBranchArrows = Object.values(widgets)\n    .filter(\n      (w) =>\n      w.type === \"arrow\" &&\n      w.id !== arrow.id &&\n      w.arrowType === \"chartBranch\" &&\n      w.chartBranch &&\n      ((w.start === arrow.start && w.points[0].type === arrow.points[0].type) ||\n       (w.end === arrow.end && w.points[1].type === arrow.points[1].type))\n    ).map(w => w as ArrowWidget);\n    \n    return chartBranchArrows.length > 0 ? chartBranchArrows[0] : null;\n  }\n\n  // updates arrow points (start/end) in both position and type\n  updateArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    const startWidget = widgets[arrow.start || \"\"];\n    const endWidget = widgets[arrow.end || \"\"];\n    const isHorizontalStart = Math.abs((startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)) > 1;\n\n    // initial dummy values\n    let points: Point[] = [{type: \"right\", x: 0, y: 0}, {type: \"left\", x: 1, y: 0}];\n\n    if(arrow.points.length === 2) {\n      points = arrow.points;\n    }\n\n    // stick to your branch side\n    if(arrow.arrowType !== \"chartBranch\") {\n      if(isHorizontalStart) {\n        if (startWidget.x + startWidget.width + TOLERANCE < endWidget.x) {\n          points[0].type = \"right\";\n          points[1].type = \"left\";\n        } else {\n          points[0].type = \"left\";\n          points[1].type = \"right\";\n        }\n      } else {\n        if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n          points[0].type = \"bottom\";\n          points[1].type = \"top\";\n        } else {\n          points[0].type = \"top\";\n          points[1].type = \"bottom\";\n        }\n      }\n    }\n\n    // chartBranch connector\n    points[0] = this.getWidgetSideMidPosition(points[0], startWidget);\n    points[1] = this.getWidgetSideMidPosition(points[1], endWidget);\n    arrow.points = points;\n      \n    if(arrow.arrowType !== \"chartBranch\") {\n      // charSide connector\n      if(this.isChartSideArrow(arrow, widgets)) {\n        this.updateArrowChartSide(arrow, startWidget, endWidget);\n      }\n      \n      // update chart branches state\n      this.setArrowChartBranch(arrow, widgets, true);\n    }\n    \n    // update non-convergent side and position for branches that require it\n    // this is mainly used for a branched arrow whose widget is \"behind\" the branch fixed position \n    if(arrow.chartBranch && arrow.chartBranch.type !== \"oneToOne\") {\n      let convergencePoint = arrow.chartBranch.type === \"manyToOne\" ? arrow.points[1] : arrow.points[0];\n      let nonConvergencePoint = arrow.chartBranch.type === \"manyToOne\" ? arrow.points[0] : arrow.points[1];\n      const convergentWidget = arrow.chartBranch.type === \"manyToOne\" ? endWidget : startWidget;\n      const nonConvergentWidget = convergentWidget === startWidget ? endWidget : startWidget;\n      \n      convergencePoint = this.getWidgetSideMidPosition(convergencePoint, convergentWidget);\n      nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n    \n      if(toOrientation(arrow.chartBranch.convergenceSide) === \"horizontal\") {\n        // if inside, use 2-segment arrow\n        if(arrow.chartBranch.position >= nonConvergentWidget.x && arrow.chartBranch.position <= nonConvergentWidget.x + nonConvergentWidget.width) {\n          nonConvergencePoint.x = arrow.chartBranch.position;\n          nonConvergencePoint.y = (nonConvergentWidget.y + nonConvergentWidget.height/2) > convergencePoint.y ? nonConvergentWidget.y : nonConvergentWidget.y + nonConvergentWidget.height;\n        // otherwise use regular 3-segment arrow but make sure it connects to the correct side\n        } else {\n          nonConvergencePoint.type = arrow.chartBranch.position < nonConvergentWidget.x ? \"left\" : \"right\";\n          nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n        }\n      } else {  // vertical\n        // if inside, use 2-segment arrow\n        if(arrow.chartBranch.position >= nonConvergentWidget.y && arrow.chartBranch.position <= nonConvergentWidget.y + nonConvergentWidget.height) {\n          nonConvergencePoint.x = (nonConvergentWidget.x + nonConvergentWidget.width/2) > convergencePoint.x ? nonConvergentWidget.x : nonConvergentWidget.x + nonConvergentWidget.width;\n          nonConvergencePoint.y = arrow.chartBranch.position;\n        // otherwise use regular 3-segment arrow but make sure it connects to the correct side\n        } else {\n          nonConvergencePoint.type = arrow.chartBranch.position < nonConvergentWidget.y ? \"top\" : \"bottom\";\n          nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n        }\n      }\n\n      arrow.points[0] = arrow.chartBranch.type === \"manyToOne\" ? nonConvergencePoint : convergencePoint;\n      arrow.points[1] = arrow.chartBranch.type === \"manyToOne\" ? convergencePoint : nonConvergencePoint;\n    }\n  }\n  \n  isChartSideArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    // can't be chartSide if there is any chartBranch on current side\n    if(this.getSharedChartBranchArrow(arrow, widgets)) return;\n\n    return ((arrow.initialIsHorizontal && (arrow.points[0].type === \"top\" || arrow.points[0].type === \"bottom\")) ||\n    (!arrow.initialIsHorizontal && (arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\")));\n  }\n\n  // returns true if using intersection chartSide\n  updateArrowChartSide(arrow: ArrowWidget, startWidget: Widget, endWidget: Widget) {\n    // if widgets limits are intersecting, use chartSide connector\n    if(arrow.initialIsHorizontal) {\n      const middleX = this.getIntersectionMiddle(startWidget.x, startWidget.width, endWidget.x, endWidget.width);\n      if(middleX) {\n        arrow.points[0].x = middleX;\n        arrow.points[1].x = middleX;\n        return true;\n      }\n    } else {\n      const middleY = this.getIntersectionMiddle(startWidget.y, startWidget.height, endWidget.y, endWidget.height);\n      if(middleY) {\n        arrow.points[0].y = middleY;\n        arrow.points[1].y = middleY;\n        return true;\n      }\n    }\n\n    // if there is no intersection, use original axis side\n    if(arrow.initialIsHorizontal) {\n      arrow.points[0].type = endWidget.x > startWidget.x + (startWidget.width / 2) ? \"right\" : \"left\";\n    } else {\n      arrow.points[0].type = endWidget.y > startWidget.y + (startWidget.height / 2) ? \"bottom\" : \"top\";\n    }\n    arrow.points[0] = this.getWidgetSideMidPosition(arrow.points[0], startWidget);\n    \n    const startWidgetCenter = {x: startWidget.x + (startWidget.width/2), y: startWidget.y + (startWidget.height/2)};\n    const endWidgetCenter = {x: endWidget.x + (endWidget.width/2), y: endWidget.y + (endWidget.height/2)};\n    const distX = Math.abs(startWidgetCenter.x - endWidgetCenter.x) - (startWidget.width/2 + endWidget.width/2);\n    const distY = Math.abs(startWidgetCenter.y - endWidgetCenter.y) - (startWidget.height/2 + endWidget.height/2);\n    const widgetsTooClose = arrow.initialIsHorizontal ? distX <= ARROW_MARGIN : distY <= ARROW_MARGIN;\n    \n    // if widgets are too close, use 2-segments arrow\n    if(widgetsTooClose) {\n      // never closer than 20px from origin and never less than 10px from target side\n      if(arrow.initialIsHorizontal) {\n        arrow.points[1].type = endWidget.y > arrow.points[0].y ? \"top\" : \"bottom\";\n        let distXToCenter = startWidget.width/2 + Math.max(distX + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n        arrow.points[1].x = startWidgetCenter.x + (arrow.points[0].type === \"right\" ? distXToCenter : -distXToCenter);\n        arrow.points[1].y = arrow.points[1].type === \"top\" ? endWidget.y : endWidget.y + endWidget.height;\n      } else {\n        arrow.points[1].type = endWidget.x > arrow.points[0].x ? \"left\" : \"right\";\n        let distYToCenter = startWidget.height/2 + Math.max(distY + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n        arrow.points[1].x = arrow.points[1].type === \"left\" ? endWidget.x : endWidget.x + endWidget.width;\n        arrow.points[1].y = startWidgetCenter.y + (arrow.points[0].type === \"bottom\" ? distYToCenter : -distYToCenter);\n      }\n    // otherwise use regular 3-segments arrow\n    } else {\n      if(arrow.initialIsHorizontal) {\n        \tarrow.points[1].type = arrow.points[0].type === \"right\" ? \"left\" : \"right\";\n      } else {\n        arrow.points[1].type = arrow.points[0].type === \"bottom\" ? \"top\" : \"bottom\";\n      }\n      arrow.points[1] = this.getWidgetSideMidPosition(arrow.points[1], endWidget);\n    }\n\n    return false;\n  }\n\n  // returns if any widgets are at \"distance\" or lower in the requested axis\n  widgetsTooClose(a: Widget, b: Widget, distance: number, horizontal: boolean) {\n    const aCenter = {x: a.x + (a.width/2), y: a.y + (a.height/2)};\n    const bCenter = {x: b.x + (b.width/2), y: b.y + (b.height/2)};\n    if(horizontal) {\n      const distX = Math.abs(aCenter.x - bCenter.x) - (a.width/2 + b.width/2);\n      return distX <= distance;\n    }\n    const distY = Math.abs(aCenter.y - bCenter.y) - (a.height/2 + b.height/2);\n    return distY <= distance;\n  }\n\n  getIntersectionMiddle(min1: number, size1: number, min2: number, size2: number) {\n    const max1 = min1 + size1;\n    const max2 = min2 + size2;\n\n    if((min1 === min2 && max1 === max2) ||\n      (min1 > min2 && min1 < max2)) {\n      const intersection = max2 - min1;\n      if(intersection <= ARROW_MARGIN * 2) return null;\n      \n      return min1 + (intersection / 2);\n    } else if(max1 > min2 && max1 < max2) {\n      const intersection = max1 - min2;\n      if(intersection <= ARROW_MARGIN * 2) return null;\n\n      return max1 - (intersection / 2);\n    }\n\n    // no intersection\n    return null;\n  }\n  \n  getWidgetSideMidPosition(point: Point, widget: Widget) {\n    let newPoint: Point = {type: point.type, x: 0, y: 0};\n    switch(point.type) {\n      case \"top\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y;\n        break;\n      case \"right\":\n        newPoint.x = widget.x + widget.width;\n        newPoint.y = widget.y + widget.height / 2;\n        break;\n      case \"bottom\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y + widget.height;\n        break;\n      case \"left\":\n        newPoint.x = widget.x;\n        newPoint.y = widget.y + widget.width / 2;\n        break;\n    }\n\n    return newPoint;\n  }\n\n  render() {\n    const { cursor, selected, widgets } = this.state;\n    return (\n      <div\n        style={{ cursor }}\n        className=\"App\"\n        tabIndex={1}\n        onContextMenu={this.handleRightClick}\n        onDoubleClick={this.handleDoubleClick}\n        onKeyDown={this.handleKeyDown}\n        onMouseMove={this.handleDrag}\n        onMouseDown={this.handleMouseDown}\n        onMouseUp={this.handleMouseUp}\n        ref={this.handleRef}\n      >\n        {Object.values(widgets).map((w) => {\n          if (w.type === \"sticky\") {\n            return (\n              <Sticky\n                cursor={cursor}\n                onRightClick={this.handleStickyRightClick}\n                onDragStart={this.handleDragStart}\n                selected={selected === w.id}\n                widget={w}\n                key={w.id}\n              />\n            );\n          }\n\n          if (w.type === \"arrow\") {\n            return <Arrow widget={w} key={w.id} />;\n          }\n\n          return null;\n        })}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}