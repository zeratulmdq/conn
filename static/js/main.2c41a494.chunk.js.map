{"version":3,"sources":["widgets/Sticky.tsx","widgets/Arrow.tsx","settings/Checkbox.tsx","types.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleDragStart","e","props","onDragStart","widget","cursor","onMouseDown","id","handleMouseUp","onMouseUp","handleMouseHover","onMouseHover","handleMouseLeave","onMouseLeave","this","selected","x","y","width","height","onMouseMove","style","top","left","border","className","SNAPPING_POINT_WIDTH","cx","cy","r","stroke","fill","React","Component","Arrow","state","draggingMiddleSegment","getPoints","points","start","end","handleSegmentDragStart","setState","handleSegmentDragEnd","pos","position","onDragSegmentEnd","undefined","connectionDot","key","isStart","onDragPointStart","handleMouseMove","clientX","clientY","type","minX","Math","min","maxX","max","minY","maxY","pathGenerator","chartBranch","isHorizontalStart","isHorizontalEnd","midDistance","d","strokeWidth","p3","p4","p1","p2","p5","d1","d2","d3","d4","pointerEvents","segment2Position","convergenceTarget","convergenceSide","path","xmlns","version","PureComponent","Checkbox","checked","handleOnChange","prevState","onCheckedChange","onChange","defaultChecked","label","stickyFactory","spec","uuid","arrowFactory","arrowType","initialIsHorizontal","toOrientation","arrowIsHorizontal","arrow","settingsStyle","borderStyle","backgroundColor","padding","App","ref","settings","stickToConvergentWidgetSide","initialId","endId","widgets","mousePosition","mouseOverSticky","handleArrowPointDragStart","startPoint","initial","endPoint","handleStickyMouseDown","updateDisconnectedArrow","handleStickyMouseUp","stopPropagation","draggingArrow","startWidget","endWidget","isHorizontalConnection","abs","setArrowChartBranch","cancelArrowCreation","handleDoubleClick","stickyWidth","ctrlKey","metaKey","s","handleDrag","deltaX","deltaY","draggingWidgets","map","length","arrows","Object","values","filter","w","connectedArrows","includes","reduce","acc","cur","updateArrow","forEach","a","movedWidgets","handleMouseHoverSticky","target","targetChanged","newWidgets","handleMouseLeaveSticky","handleWidgetDragStart","shiftKey","button","handleKeyDown","newCursor","selectedWidgetsId","prevWidgets","handleMouseDown","isDraggingArrow","getConnectedStickyPos","point","coords","STICKY_HEIGHT","draggingPoint","isChartSideArrow","updateArrowChartSide","handleRef","focus","handleDragSegmentEnd","arrowId","draggingWidget","console","log","chartBranchArrow","getSharedChartBranchArrow","assign","chartBranchArrows","draggingPosition","connectedWidget","startPosition","endPosition","getWidgetSideMidPosition","snappingPoint","convergesOnEnd","convergencePoint","nonConvergencePoint","convergentWidget","nonConvergentWidget","middleX","getIntersectionMiddle","middleY","startWidgetCenter","endWidgetCenter","distX","distY","distXToCenter","distYToCenter","b","distance","horizontal","aCenter","bCenter","min1","size1","min2","size2","max1","max2","intersection","ARROW_MARGIN","value","newPoint","tabIndex","onDoubleClick","onKeyDown","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.2c41a494.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\nconst SNAPPING_POINT_WIDTH = 30;\nconst SNAPPING_POINT_CENTER = SNAPPING_POINT_WIDTH / 2;\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onMouseDown: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onMouseUp: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDragStart: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onMouseHover: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onMouseLeave: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  selected: boolean;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.Component<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onDragStart, widget, cursor, onMouseDown } = this.props;\n    if (cursor === 'crosshair') onMouseDown(widget.id, e);\n    else onDragStart(widget.id, e);\n  };\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onMouseUp, cursor, widget } = this.props;\n    if (cursor === 'crosshair') onMouseUp(widget.id, e);\n  };\n  \n  handleMouseHover = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onMouseHover, widget } = this.props;\n    onMouseHover(widget.id, e);\n  };\n\n  handleMouseLeave = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onMouseLeave, widget } = this.props;\n    onMouseLeave(widget.id, e);\n  };\n\n  render() {\n    const {\n      cursor,\n      selected,\n      widget: { x, y , width, height},\n    } = this.props;\n    return (\n      <div\n        onMouseUp={this.handleMouseUp}\n        onMouseDown={this.handleDragStart}\n        onMouseMove={this.handleMouseHover}\n        onMouseLeave={this.handleMouseLeave}\n        style={{\n          top: y,\n          left: x,\n          width: width,\n          height: height,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n          border: selected ? \"2px solid blue\" : \"none\",\n        }}\n        className=\"Sticky\"\n        >\n        <div\n          className=\"snapping-point top\"\n          style={{\n            top: 0 - SNAPPING_POINT_CENTER,\n            left: (width / 2) - SNAPPING_POINT_CENTER,\n            width: SNAPPING_POINT_WIDTH,\n            height: SNAPPING_POINT_WIDTH,\n          }}\n          id=\"top\"\n        ></div>\n        <div\n          className=\"snapping-point right\"\n          style={{\n            top: (height / 2) - SNAPPING_POINT_CENTER,\n            left: width - SNAPPING_POINT_CENTER,\n            width: SNAPPING_POINT_WIDTH,\n            height: SNAPPING_POINT_WIDTH,\n          }}\n          id=\"right\"\n        ></div>\n        <div\n          className=\"snapping-point bottom\"\n          style={{\n            top: height - SNAPPING_POINT_CENTER,\n            left: (width / 2) - SNAPPING_POINT_CENTER,\n            width: SNAPPING_POINT_WIDTH,\n            height: SNAPPING_POINT_WIDTH,\n          }}\n          id=\"bottom\"\n        ></div>\n        <div\n          className=\"snapping-point left\"\n          style={{\n            top: (height / 2) - SNAPPING_POINT_CENTER,\n            left: 0 - SNAPPING_POINT_CENTER,\n            width: SNAPPING_POINT_WIDTH,\n            height: SNAPPING_POINT_WIDTH,\n          }}\n          id=\"left\"\n        ></div>\n        <svg className=\"auto-affordance\">\n        <circle\n          cx={`${width / 2}`}\n          cy={`${height / 2}`}\n          r=\"5\"\n          stroke={'#1c7ff9'}\n          fill='none'\n          ></circle>\n          </svg>\n      </div>\n    );\n  }\n}\n\nexport default Sticky;\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport \"./Arrow.css\";\nimport { ArrowWidget, ChartBranch, Point } from \"../types\";\n\ntype Direction = 'horizontal' | 'vertical' | 'other';\n\nconst MIN_SEGMENT_DISTANCE = 10;\n\ninterface PropTypes {\n  widget: ArrowWidget;\n  onDragPointStart: (id: string, e: React.MouseEvent, isStart: boolean) => void;\n  onDragSegmentEnd: (id: string, position?: number) => void;\n}\n\ninterface State {\n  draggingMiddleSegment: boolean;\n  position?: number;\n}\n\nclass Arrow extends React.PureComponent<PropTypes, State> {\n  state: State = { draggingMiddleSegment: false };\n\n  getPoints = () => {\n    const { points } = this.props.widget;\n    const start = points[0];\n    const end = points[1];\n\n    return { start, end }\n  }\n\n  handleSegmentDragStart = () => {\n    if (this.state.draggingMiddleSegment) return;\n    this.setState({ draggingMiddleSegment: true})\n  }\n\n  handleSegmentDragEnd = () => {\n    if (!this.state.draggingMiddleSegment) return;\n    // Create chart branch afeter dragging middle segment\n    const pos = this.state.position;\n    this.props.onDragSegmentEnd(this.props.widget.id, pos);\n    this.setState({ draggingMiddleSegment: false, position: undefined })\n  }\n\n  connectionDot = (x: number, y: number, key: string, isStart?: boolean) => {\n    const handleDragPointStart = (e: React.MouseEvent) => {\n      const { onDragPointStart, widget } = this.props;\n      onDragPointStart(widget.id, e, !!isStart);\n    }\n    return <circle\n      key={key}\n      cx={`${x}`}\n      cy={`${y}`}\n      r=\"5\"\n      stroke={isStart ? 'black' : '#1c7ff9'}\n      fill={isStart ? 'white' : '#1c7ff9'}\n      onMouseDown={handleDragPointStart}\n      ></circle>\n  };\n\n  handleMouseMove = ({ clientX, clientY }: React.MouseEvent<SVGSVGElement, MouseEvent>) => {\n    if(!this.state.draggingMiddleSegment) return;\n\n    const { start, end } = this.getPoints();\n\n    if (start.type === 'right' || start.type === 'left') {\n      const minX = Math.min(start.x, end.x);\n      const maxX = Math.max(start.x, end.x);\n      if (start.type === end.type) {\n        if (maxX < clientX - MIN_SEGMENT_DISTANCE || clientX + MIN_SEGMENT_DISTANCE < minX) {\n          this.setState({ position: clientX });\n          return;\n        }\n      }\n\n      const limitStart = minX < clientX - MIN_SEGMENT_DISTANCE;\n      const limitEnd = maxX > clientX + MIN_SEGMENT_DISTANCE;\n\n      if (limitStart && limitEnd && this.state.position !== clientX)\n        this.setState({ position: clientX })\n        return;\n    }\n\n    const minY = Math.min(start.y, end.y);\n    const maxY = Math.max(start.y, end.y);\n    if (start.type === end.type) {\n      if (maxY < clientY - MIN_SEGMENT_DISTANCE || clientY + MIN_SEGMENT_DISTANCE < maxY) {\n        this.setState({ position: clientY });\n        return;\n      }\n    }\n\n    const limitStart = minY < clientY - MIN_SEGMENT_DISTANCE;\n    const limitEnd = maxY > clientY + MIN_SEGMENT_DISTANCE;\n\n    if (limitStart && limitEnd && this.state.position !== clientY)\n      this.setState({ position: clientY });\n  }\n\n  pathGenerator = (\n    points: Point[],\n    chartBranch: ChartBranch | null,\n    position: number | undefined,\n  ) => {\n    const start = points[0];\n    const end = points[1];\n    const isHorizontalStart = start.type === \"right\" || start.type === \"left\";\n    const isHorizontalEnd = end.type === \"right\" || end.type === \"left\";\n    const midDistance = isHorizontalStart ? (end.x - start.x) / 2 : (end.y - start.y) / 2;\n\n    // 1-segment straight line\n    if((isHorizontalStart && start.y === end.y) ||\n      (!isHorizontalStart && start.x === end.x)) {\n        const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n        return [\n          this.connectionDot(start.x, start.y, '0', true),\n          <path d={d} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"1\" />,\n          this.connectionDot(end.x, end.y, '2'),\n        ];\n    }\n\n    if(isHorizontalStart !== isHorizontalEnd) {\n      const willCoverContent = isHorizontalStart\n      ? (end.type === \"bottom\" && end.y > start.y) || (end.type === \"top\" && end.y < start.y)\n      : (end.type === \"right\" && end.x > start.x) || (end.type === \"left\" && end.x < start.x);\n      // 2-segments line\n      if (!willCoverContent) {\n        const p1 = `${start.x} ${start.y}`;\n        const p2 = isHorizontalStart ? `${end.x} ${start.y}` : `${start.x} ${end.y}`;\n        const p3 = `${end.x} ${end.y}`;\n  \n        const d1 = `M ${p1} L ${p2}`;\n        const d2 = `M ${p2} L ${p3}`;\n        return [\n          this.connectionDot(start.x, start.y, '0', true),\n          <path d={d1} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"1\" />,\n          <path d={d2} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"2\" />,\n          this.connectionDot(end.x, end.y, '3'),\n        ];\n      // 4-segments line\n      } else {\n        const p1 = `${start.x} ${start.y}`;\n        const p2 = isHorizontalStart ? `${start.x + midDistance} ${start.y}` : ` ${start.x} ${start.y + midDistance}`;\n        const p5 = `${end.x} ${end.y}`;\n        let p3, p4;\n        if (end.type === \"bottom\" || end.type === \"right\") {\n          p3 = isHorizontalStart ? `${start.x + midDistance} ${end.y + 20}` : ` ${end.x + 20} ${start.y + midDistance}`;\n          p4 = isHorizontalStart ? `${end.x} ${end.y + 20}` : ` ${end.x + 20} ${end.y}`;\n        } else {\n          p3 = isHorizontalStart ? `${start.x + midDistance} ${end.y - 20}` : ` ${end.x - 20} ${start.y + midDistance}`;\n          p4 = isHorizontalStart ? `${end.x} ${end.y - 20}` : ` ${end.x - 20} ${end.y}`;\n        }\n\n        const d1 = `M ${p1} L ${p2}`;\n        const d2 = `M ${p2} L ${p3}`;\n        const d3 = `M ${p3} L ${p4}`;\n        const d4 = `M ${p4} L ${p5}`;\n        return [\n          this.connectionDot(start.x, start.y, '0', true),\n          <path d={d1} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"1\" />,\n          <path\n            key=\"2\"\n            d={d2}\n            stroke=\"black\"\n            strokeWidth=\"2\"\n            fill=\"none\"\n          />,\n          <path d={d3} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"3\" />,\n          <path d={d4} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"4\" />,\n          this.connectionDot(end.x, end.y, '5'),\n        ];\n      }\n    }\n    const willCoverContent = isHorizontalStart\n      ? (end.type === \"right\" && end.x > start.x) || (end.type === \"left\" && end.x < start.x)\n      : (end.type === \"bottom\" && end.y > start.y) || (end.type === \"top\" && end.y < start.y);\n    // 3-segments line\n    const cursor = isHorizontalStart ? 'ew-resize' : 'ns-resize';\n    if (willCoverContent && !chartBranch) {\n      const p1 = `${start.x} ${start.y}`;\n      const p4 = `${end.x} ${end.y}`;\n      let p2, p3;\n      if (end.type === \"bottom\" || end.type === \"right\") {\n        p2 = isHorizontalStart ? `${end.x + 20} ${start.y}` : ` ${start.x} ${end.y + 20}`;\n        p3 = isHorizontalStart ? `${end.x + 20} ${end.y}` : ` ${end.x} ${end.y + 20}`;\n      } else {\n        p2 = isHorizontalStart ? `${end.x - 20} ${start.y}` : ` ${start.x} ${end.y - 20}`;\n        p3 = isHorizontalStart ? `${end.x - 20} ${end.y}` : ` ${end.x} ${end.y - 20}`;\n      }\n\n      const d1 = `M ${p1} L ${p2}`;\n      const d2 = `M ${p2} L ${p3}`;\n      const d3 = `M ${p3} L ${p4}`;\n\n      return [\n        this.connectionDot(start.x, start.y, '0', true),\n        <path d={d1} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"1\" />,\n        <path\n          key=\"2\"\n          d={d2}\n          stroke=\"black\"\n          strokeWidth=\"2\"\n          fill=\"none\"\n          style={{\n            cursor,\n            pointerEvents: 'auto'\n          }}\n          onMouseDown={this.handleSegmentDragStart}\n        />,\n        <path d={d3} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"3\" />,\n        this.connectionDot(end.x, end.y, '4'),\n      ];\n    }\n    let segment2Position = position\n      ? position\n      : isHorizontalStart\n      ? start.x + midDistance\n      : start.y + midDistance;\n\n    if(chartBranch)\n    {\n      const convergenceTarget = chartBranch.type === \"manyToOne\" ? end : start;\n      if(chartBranch.convergenceSide === convergenceTarget.type) {\n        segment2Position = position\n          ? position\n          : chartBranch.position;\n      }\n    }\n\n    const p1 = `${start.x} ${start.y}`;\n    const p2 = isHorizontalStart ? `${segment2Position} ${start.y}` : ` ${start.x} ${segment2Position}`;\n    const p3 = isHorizontalStart ? `${segment2Position} ${end.y}` : ` ${end.x} ${segment2Position}`;\n    const p4 = `${end.x} ${end.y}`;\n\n    const d1 = `M ${p1} L ${p2}`;\n    const d2 = `M ${p2} L ${p3}`;\n    const d3 = `M ${p3} L ${p4}`;\n\n    return [\n      this.connectionDot(start.x, start.y, '0', true),\n      <path d={d1} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"1\" />,\n      <path\n        key=\"2\"\n        d={d2}\n        stroke=\"black\"\n        strokeWidth=\"2\"\n        fill=\"none\"\n        style={{\n          cursor,\n          pointerEvents: 'auto'\n        }}\n        onMouseDown={this.handleSegmentDragStart}\n      />,\n      <path d={d3} stroke=\"black\" strokeWidth=\"2\" fill=\"none\" key=\"3\" />,\n      this.connectionDot(end.x, end.y, '4'),\n    ];\n  };\n\n  render() {\n    const path = this.pathGenerator(\n      this.props.widget.points,\n      this.props.widget.chartBranch,\n      this.state.position,\n    );\n\n    return (\n      <svg\n        style={{\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          pointerEvents: this.state.draggingMiddleSegment ? \"auto\" : \"none\",\n        }}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        version=\"1.1\"\n        className=\"Arrow\"\n        onMouseUp={this.handleSegmentDragEnd}\n        onMouseMove={this.handleMouseMove}\n      >\n        { path }\n      </svg>\n    );\n  }\n}\n\nexport default Arrow;","import React from \"react\";\r\n\r\ninterface PropTypes {\r\n  label: string;\r\n  onCheckedChange: (checked: boolean) => void;\r\n}\r\n\r\ninterface State {\r\n  checked: boolean;\r\n}\r\n\r\nclass Checkbox extends React.PureComponent<PropTypes, State> {\r\n  state: State = {\r\n    checked: false,\r\n  };\r\n\r\n  handleOnChange = (e: React.ChangeEvent<HTMLInputElement>) => { \r\n    this.setState((prevState) => {\r\n      const checked = !prevState.checked;\r\n      this.props.onCheckedChange(checked);\r\n      return {\r\n        checked\r\n      };\r\n    });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div style={{height: \"auto\"}}>\r\n        <label>\r\n          <input\r\n            type=\"checkbox\"\r\n            style={{width: 15, height: 15}}\r\n            onChange={this.handleOnChange}\r\n            defaultChecked={this.state.checked} />\r\n          {this.props.label}\r\n        </label>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Checkbox;","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\nexport type Orientation = \"horizontal\" | \"vertical\";\nexport type ChartBranchType = \"oneToOne\" | \"oneToMany\" | \"manyToOne\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type: PointType;\n}\n\nexport interface Position {\n  x: number;\n  y: number;\n}\n\nexport interface ChartBranch {\n  position: number; // fixed position where arrows share the 2nd branch segment\n  convergenceSide: PointType;  // side of the widget where the arrows converge (might be start or end widget depending of ChartBranchType)\n  type: ChartBranchType;\n}\n\n// initial: initial simple arrow, centered to the connected widgets on both ends, bent into 3 segments having the same length in both parallel segments.\n// chartBranch: created from an 'initial' arrow, centered to the connected widgets on both ends, bent into 3 segments, can share inital segment with other 'chartBranch' arrows, 1st segment size stays put.\n// chartSide: created from an 'initial' arrow, moved to the side of a group of 'chartBranch' arrows and can be on any point of both connected widgets.\nexport type ArrowType = \"initial\" | \"chartBranch\" | \"chartSide\";\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  startPoint?: PointType | null;\n  endPoint?: PointType | null;\n  end: string | null;\n  arrowType: ArrowType;\n  chartBranch: ChartBranch | null;\n  initialIsHorizontal: boolean;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: spec.height ?? 100,\n  width: spec.width ?? 100,\n  type: \"sticky\",\n  x: spec.x || 0,\n  y: spec.y || 0,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n  arrowType: spec.arrowType || \"initial\",\n  chartBranch: null,\n  initialIsHorizontal: spec.initialIsHorizontal || true,\n});\n\nexport const toOrientation = (type: PointType) : Orientation => {\n  return type === \"left\" || type === \"right\" ? \"horizontal\" : \"vertical\";\n}\n","import React, { CSSProperties } from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport Arrow from \"./widgets/Arrow\";\nimport Checkbox from \"./settings/Checkbox\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n  Position,\n  toOrientation,\n  ChartBranch,\n  PointType,\n} from \"./types\";\n\nexport const TOLERANCE = 10;\nexport const ARROW_MARGIN = 10;\nexport const TWO_SEGMENT_ARROW_MIN = 20;\nexport const STICKY_HEIGHT = 100;\n\nconst arrowIsHorizontal = (arrow: ArrowWidget) =>\n  arrow.points[0].type === 'left' || arrow.points[0].type === 'right';\n\nexport const settingsStyle: React.CSSProperties = {\n  position: \"absolute\",\n  top: 0,\n  width:\"auto\",\n  height: \"auto\",\n  borderStyle: \"solid\",\n  backgroundColor: \"lightgray\",\n  padding: 10,\n};\n\ninterface State {\n  settings:{\n    stickToConvergentWidgetSide: boolean;\n  };\n  cursor: React.CSSProperties[\"cursor\"];\n  dragging: string[] | null;\n  initialId: string | null;\n  endId: string | null;\n  selected: string[] | null;\n  widgets: Record<string, Widget>;\n}\n\nclass App extends React.Component<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    settings :{\n      stickToConvergentWidgetSide: false,\n    },\n    cursor: \"auto\",\n    dragging: null,\n    initialId: null,\n    endId: null,\n    selected: null,\n    widgets: {},\n  };\n  mousePosition: Position | null = null;\n  mouseOverSticky: boolean = false;\n\n  cancelArrowCreation() {\n    this.setState((prevState) => {\n      if(prevState.dragging && prevState.dragging.length) {\n        // delete dragging arrow if any\n        const draggingWidget = { ...prevState.widgets[prevState.dragging[0]] };\n        if(draggingWidget.type === \"arrow\") {\n          const prevWidgets = prevState.widgets;\n          delete prevWidgets[draggingWidget.id];\n          return {\n            ...prevState,\n            dragging: null,\n            initialId: null,\n            endId: null,\n            cursor: \"auto\",\n            widgets: { ...prevWidgets },\n          }\n        }\n      }\n\n      return {\n        ...prevState,\n        dragging: null,\n        initialId: null,\n        endId: null,\n        cursor: \"auto\",\n      }\n    });\n  }\n\n  handleArrowPointDragStart = (id: string, e: React.MouseEvent, isStart: boolean) => {\n    if (isStart) {\n      const end = (this.state.widgets[id] as ArrowWidget).end;\n      this.setState((prevState) => (\n        {\n          ...prevState,\n          cursor: 'crosshair',\n          dragging: [id],\n          endId: end,\n          initialId: null,\n          widgets: {\n            ...prevState.widgets,\n            [id]: {\n              ...prevState.widgets[id],\n              start: null,\n              startPoint: null,\n            }\n          }\n        }\n      ));\n    } else {\n      const initial = (this.state.widgets[id] as ArrowWidget).start;\n      this.setState((prevState) => (\n        {\n          ...prevState,\n          cursor: 'crosshair',\n          dragging: [id],\n          initialId: initial,\n          endId: null,\n          widgets: {\n            ...prevState.widgets,\n            [id]: {\n              ...prevState.widgets[id],\n              end: null,\n              endPoint: null,\n            }\n          }\n        }\n      ));\n    }\n  }\n\n  handleStickyMouseDown = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    if (this.state.cursor !== \"crosshair\")\n      return;\n    // start arrow creation\n    if (!this.state.dragging) {\n      const mousePosition: Position = {x: e.clientX, y: e.clientY };\n      // this.setState({initialId: id});\n\n      // create Arrow for dragging without end widget\n      this.setState((prevState) => {\n        const arrow = {\n          ...arrowFactory({ start: id, end: null }),\n        };\n\n        this.updateDisconnectedArrow(arrow, prevState.widgets, mousePosition);\n\n        return {\n          ...prevState,\n          initialId: id,\n          endId: null,\n          widgets: {\n            ...prevState.widgets,\n            [arrow.id]: arrow,\n          },\n          dragging: [arrow.id],\n        };\n      });\n\n      return;\n    }\n  }\n\n  handleStickyMouseUp = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.stopPropagation(); // avoid executing `handleMouseUp`\n    if (this.state.initialId === id || this.state.endId === id) {\n      this.cancelArrowCreation();\n      return;\n    }\n\n    if (this.state.cursor !== \"crosshair\")\n      return;\n    \n    this.setState((prevState) => {\n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      const draggingArrow = { ...prevState.widgets[prevState.dragging[0]] } as ArrowWidget;\n      const startWidget = prevState.widgets[draggingArrow.start ?? id];\n      const endWidget = prevState.widgets[draggingArrow.end ?? id];\n      \n      // update Arrow start/end and connect it to both widgets\n      const isHorizontalConnection = Math.abs((startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)) > 1;\n      draggingArrow.start = startWidget.id;\n      draggingArrow.end = endWidget.id;\n      draggingArrow.initialIsHorizontal = isHorizontalConnection;\n      // update chart branches state (for both start and end arrows)\n      this.setArrowChartBranch(draggingArrow as ArrowWidget, this.state.widgets, false);\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        dragging: null,\n        initialId: null,\n        endId: null,\n        widgets: {\n          ...prevState.widgets,\n          [draggingArrow.id]: draggingArrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    // create rectangular stickies while holding CTRL down\n    const stickyWidth = (e.ctrlKey || e.metaKey) ? 150 : 100;\n    const s = stickyFactory({ x: e.clientX - (stickyWidth / 2), y: e.clientY - 50, width: stickyWidth });\n    this.setState((prevState) => ({\n      selected: [s.id],\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (e: React.MouseEvent<HTMLDivElement>) => {\n    const deltaX = this.mousePosition ? e.clientX - this.mousePosition.x : e.clientX;\n    const deltaY = this.mousePosition ? e.clientY - this.mousePosition.y : e.clientY;\n    this.mousePosition = {x: e.clientX, y: e.clientY };\n    const { dragging, widgets } = this.state;\n\n    if (!dragging)\n      return;\n    const draggingWidgets = dragging.map(id => widgets[id]);\n    if(draggingWidgets.length > 1 || draggingWidgets[0].type === \"sticky\") {\n      const arrows = Object.values(widgets).filter(w => w.type === \"arrow\") as ArrowWidget[];\n      // update connected arrows\n      const connectedArrows = Object.values(widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          dragging &&\n          ((w.start && dragging.includes(w.start)) ||\n          (w.end && dragging.includes(w.end))))\n      .reduce((acc, cur) => {\n        const arrow = cur as ArrowWidget;\n        this.updateArrow(arrow, widgets);\n        if (dragging &&\n          ((arrow.start && dragging.includes(arrow.start)) &&\n          (arrow.end && dragging.includes(arrow.end))) &&\n          arrow.chartBranch) {\n            if (arrow.chartBranch.type === 'oneToOne') {\n              arrow.chartBranch.position = arrow.chartBranch.position + (arrowIsHorizontal(arrow) ? deltaX : deltaY);\n            } else {\n              arrows.forEach(a => {\n                if (a.chartBranch && a.chartBranch?.position === arrow.chartBranch?.position) {\n                  if ((a.end && !dragging.includes(a.end)) || (a.start && !dragging.includes(a.start))) {\n                    return;\n                  } else {\n                    arrow.chartBranch.position = arrow.chartBranch.position + (arrowIsHorizontal(arrow) ? deltaX : deltaY);\n                  }\n                }\n              })\n            }\n          }\n        \n        return {\n          ...acc,\n          [arrow.id]: {\n            ...arrow,\n          },\n        };\n      }, {} as Record<string, Widget>);\n  \n      const movedWidgets: Record<string, Widget> = draggingWidgets.reduce((acc, cur) => {\n        return {\n          ...acc,\n          [cur.id]: {\n            ...cur,\n            x: cur.x + deltaX,\n            y: cur.y + deltaY,\n          }\n        };\n      }, {});\n      this.setState({\n        widgets: {\n          ...widgets,\n          ...movedWidgets,\n          ...connectedArrows,\n        }\n      });\n    } else if (draggingWidgets[0].type === \"arrow\" && !this.mouseOverSticky) {\n      const draggingArrow = { ...draggingWidgets[0] };\n      // update arrow dragged end\n      if (!draggingArrow.end || !draggingArrow.start)\n        this.updateDisconnectedArrow(draggingArrow, widgets, this.mousePosition);\n      \n      this.setState({\n        widgets: {\n          ...widgets,\n          [draggingArrow.id]: draggingArrow,\n        },\n      });\n    }\n  };\n\n  handleMouseHoverSticky = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    this.mouseOverSticky = true;\n    const target = (e.target as Element).id || null;\n    const { dragging, widgets } = this.state;\n    if (!dragging) return;\n    // stick to widget when hovering while dragging\n    const draggingWidgets = dragging.map(id => widgets[id]);\n    if(draggingWidgets.length === 1 &&\n      draggingWidgets[0].type === \"arrow\") {\n        const draggingArrow = { ...draggingWidgets[0] };\n        const startWidget = this.state.widgets[draggingArrow.start ?? id];\n        const endWidget = this.state.widgets[draggingArrow.end ?? id];\n        // update Arrow start/end and connect it to both widgets\n        const isStart = !!this.state.endId;\n        const isHorizontalConnection = Math.abs((startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)) > 1;\n        draggingArrow.initialIsHorizontal = isHorizontalConnection && !(isStart && (target === 'bottom' || target === 'top'));\n        const targetChanged = isStart\n          ? draggingArrow.startPoint !== target && draggingArrow.start === id\n          : draggingArrow.endPoint !== target && draggingArrow.end === id;\n        if ((draggingArrow.start !== id &&\n          draggingArrow.end !== id) || targetChanged)\n          {\n            // connect to widget and update arrow\n            draggingArrow.start = draggingArrow.start ?? id;\n            draggingArrow.end = draggingArrow.end ?? id;\n            this.updateArrow(draggingArrow, widgets, target as PointType || 'auto', isStart);\n            const newWidgets = { ...widgets, [draggingArrow.id]: draggingArrow };\n            this.setState({\n              widgets: newWidgets,\n            });\n          }\n    };\n  }\n\n  handleMouseLeaveSticky = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    this.mouseOverSticky = false;\n    const { dragging, widgets } = this.state;\n    if (!dragging) return;\n    const draggingWidgets = dragging.map(id => widgets[id]);\n    if (draggingWidgets.length === 1 &&\n      draggingWidgets[0].type === \"arrow\" &&\n      draggingWidgets[0].start && draggingWidgets[0].end &&\n      (draggingWidgets[0].start === id ||\n      draggingWidgets[0].end === id)) {\n      // disconnect from widget and update arrow\n      const draggingArrow = { ...draggingWidgets[0] };\n      draggingArrow.start = draggingArrow.start === id ? null : draggingArrow.start;\n      draggingArrow.end = draggingArrow.end === id ? null : draggingArrow.end;\n      \n      this.setState({\n        widgets: {\n          ...widgets,\n          [draggingArrow.id]: draggingArrow,\n        },\n      });\n    }\n  }\n\n  handleWidgetDragStart = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const { shiftKey } = e;\n    e.stopPropagation();\n\n    if (e.button !== 0)\n      return;\n\n    if(this.state.dragging)\n      return;\n\n    const selected = (this.state.selected && (this.state.selected.includes(id) || shiftKey))\n    ? !this.state.selected.includes(id)\n      ? [...this.state.selected, id]\n      : this.state.selected\n    : [id];\n    const dragging = (this.state.selected && this.state.selected.includes(id)) ? this.state.selected : [id];\n\n    this.setState({\n      dragging,\n      selected,\n    });\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if(e.key === \"c\" || e.key === \"C\") {\n      const newCursor = this.state.cursor === \"auto\" ? \"crosshair\" : \"auto\";\n      if(newCursor === \"auto\") {\n        this.cancelArrowCreation();\n      } else {\n        this.setState({\n          cursor: newCursor,\n        });\n      }\n    }\n\n    if ((e.key === \"Backspace\" || e.key === \"Delete\") && !!this.state.selected) {\n      this.setState((prevState) => {\n        const selectedWidgetsId = prevState.selected || null;\n        const prevWidgets = prevState.widgets;\n        selectedWidgetsId?.forEach(id => {\n          Object.values(prevWidgets).forEach((w) => {\n            if (w.type === \"arrow\" && (w.start === id || w.end === id))\n              delete prevWidgets[w.id];\n          });\n          delete prevWidgets[id]\n        });\n\n        return {\n          ...prevState,\n          selected: null,\n          widgets: { ...prevWidgets },\n        };\n      });\n    }\n  };\n\n  handleMouseDown = () => {\n    this.setState({ selected: null });\n  };\n\n  // true when creating an arrow, or when dragging arrow point\n  isDraggingArrow = () => {\n    const draggingWidgets = this.state.dragging && this.state.dragging.map(id => this.state.widgets[id]);\n    return draggingWidgets && draggingWidgets.length === 1 && draggingWidgets[0].type === \"arrow\";\n  }\n\n  getConnectedStickyPos = (point: Point, stickyWidth: number) => {\n    let coords = { x: 0, y: 0 };\n    switch(point.type) {\n      case \"top\":\n        coords.x = point.x - stickyWidth / 2;\n        coords.y = point.y;\n        break;\n      case \"right\":\n        coords.x = point.x - stickyWidth;\n        coords.y = point.y - STICKY_HEIGHT / 2;\n        break;\n      case \"bottom\":\n        coords.x = point.x - stickyWidth / 2;\n        coords.y = point.y - STICKY_HEIGHT;\n        break;\n      case \"left\":\n        coords.x = point.x;\n        coords.y = point.y - stickyWidth / 2;\n        break;\n    }\n\n    return coords;\n  }\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    if(this.isDraggingArrow()) {\n      if (this.state.initialId || this.state.endId) {\n        if (this.state.endId) {\n          this.cancelArrowCreation();\n          return;\n        }\n        // sticky auto-creation after dropping an arrow in the canvas\n        const stickyWidth = (e.ctrlKey || e.metaKey) ? 150 : 100;\n        const draggingWidgets = this.state.dragging && this.state.dragging.map(id => this.state.widgets[id]);\n        const draggingArrow = draggingWidgets && { ...draggingWidgets[0] as ArrowWidget };\n        const draggingPoint = draggingArrow && draggingArrow.points[1];\n        if (!draggingPoint || !draggingArrow) return;\n        const pos = this.getConnectedStickyPos(draggingPoint, stickyWidth);\n        const s = stickyFactory({ ...pos, width: stickyWidth });\n        draggingArrow.end = s.id;\n        draggingArrow.initialIsHorizontal = arrowIsHorizontal(draggingArrow);\n        // update chart branches state (for both start and end arrows)\n        this.setArrowChartBranch(draggingArrow as ArrowWidget, this.state.widgets, false);\n        if (draggingArrow) {\n          this.setState({\n            selected: [s.id],\n            dragging: null,\n            initialId: null,\n            endId: null,\n            cursor: \"auto\",\n            widgets: {\n              ...this.state.widgets,\n              [s.id]: s,\n              [draggingArrow.id]: {\n                ...draggingArrow,\n              }\n            },\n          });\n        }\n      }\n      return;\n    }\n    this.setState((prevState) => {\n      \n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      const connectedArrows = Object.values(prevState.widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          (((w.start && prevState.dragging?.includes(w.start)) || (w.end && prevState.dragging?.includes(w.end))))\n      ).map(w=> w as ArrowWidget)\n      .reduce((acc, arrow) => {\n\n        // stick to your branch side\n        if(!prevState.settings.stickToConvergentWidgetSide || arrow.arrowType !== \"chartBranch\") {\n          if(this.isChartSideArrow(arrow, prevState.widgets)) {\n            const startWidget = prevState.widgets[arrow.start || \"\"] as StickyWidget;\n            const endWidget = prevState.widgets[arrow.end || \"\"] as StickyWidget;\n            if(this.updateArrowChartSide(arrow, startWidget, endWidget)) {\n              arrow.arrowType = \"chartSide\";\n            }\n          }\n          \n          // update chart branches state (for both start and end arrows)\n          this.setArrowChartBranch(arrow, prevState.widgets, false);\n        }\n          \n        // update initial axis\n        arrow.initialIsHorizontal = arrowIsHorizontal(arrow);\n\n        return {\n          ...acc,\n          [arrow.id]: {\n            ...arrow,\n          },\n        };\n      }, {} as Record<string, Widget>);\n      \n      return {\n        dragging: null,\n        widgets: {\n          ...prevState.widgets,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleRef = (ref: HTMLDivElement) => {\n    this.ref = ref;\n    // start focused to listen for key presses\n    if(this.ref) {\n      this.ref.focus();\n    }\n  }\n\n  handleDragSegmentEnd = (arrowId: string, position?: number) => {\n    const arrow = this.state.widgets[arrowId];\n    this.setArrowChartBranch(arrow as ArrowWidget, this.state.widgets, false, position);\n  }\n\n  // finds if this arrow should be a part of a branchChart\n  setArrowChartBranch(arrow: ArrowWidget, widgets: Record<string, Widget>, dragging: boolean, position?: number) {\n    if(!this.state.settings.stickToConvergentWidgetSide && arrow.chartBranch) {\n      // don't recalculate if chartBranchSide and position didn't change\n      let convergencePoint = arrow.chartBranch.type === \"manyToOne\" ? arrow.points[1] : arrow.points[0];\n      if(convergencePoint.type === arrow.chartBranch.convergenceSide && (!position || arrow.chartBranch.position === position)) {\n        console.log('not recalculating chart branch');\n        return;\n      }\n    }\n    \n    const chartBranchArrow = this.getSharedChartBranchArrow(arrow, widgets);\n    // don't force chartBranching while dragging on an empty side of the origin/end widget\n    // or if arrow has explicitly set start or end point\n    if((dragging && !chartBranchArrow)) {\n      arrow.chartBranch = null;\n      console.log('setting chart branch null');\n      return;\n    }\n\n    arrow.arrowType = \"chartBranch\";\n    \n    if(chartBranchArrow && chartBranchArrow.chartBranch && !position) {\n      console.log('become part of an existing chartBranch');\n      // become part of an existing chartBranch\n      if(chartBranchArrow.chartBranch.type === \"oneToOne\") {\n        // if we are just adding the 2nd arrow to this chartBranch, update type and convergenceSide beforehand\n        if(chartBranchArrow.start === arrow.start ){\n          chartBranchArrow.chartBranch.type = \"oneToMany\";\n          chartBranchArrow.chartBranch.convergenceSide = arrow.points[0].type;\n        } else {\n          chartBranchArrow.chartBranch.type = \"manyToOne\";\n          chartBranchArrow.chartBranch.convergenceSide = arrow.points[1].type;\n        }\n      }\n      arrow.chartBranch = Object.assign({}, chartBranchArrow.chartBranch);\n    } else if ((!arrow.startPoint && !arrow.endPoint) || position) {\n      // new lonely charBranch arrow\n      console.log('new lonely charBranch arrow');\n      let chartBranch: ChartBranch = {\n        position: position || 0,\n        convergenceSide: arrow.points[0].type,\n        type: \"oneToOne\"\n      };\n      // on new branch, set 2nd segment position to half the distance in X or Y depending on orientation\n      // unless explicit position is passed as parameter\n      if (!position) {\n        if(toOrientation(chartBranch.convergenceSide) === \"horizontal\") {\n          chartBranch.position = arrow.points[0].x + ((arrow.points[1].x - arrow.points[0].x) / 2);\n        } else {\n          chartBranch.position = arrow.points[0].y + ((arrow.points[1].y - arrow.points[0].y) / 2);\n        }\n      }\n      arrow.chartBranch = chartBranch;\n    }\n  }\n\n  // find another arrow that share same origin or end point and already has chartBranch defined\n  getSharedChartBranchArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    const chartBranchArrows = Object.values(widgets)\n    .filter(\n      (w) =>\n      w.type === \"arrow\" &&\n      w.id !== arrow.id &&\n      w.arrowType === \"chartBranch\" &&\n      w.chartBranch &&\n      ((w.start === arrow.start && w.points[0].type === arrow.points[0].type) ||\n       (w.end === arrow.end && w.points[1].type === arrow.points[1].type))\n    ).map(w => w as ArrowWidget);\n    \n    return chartBranchArrows.length > 0 ? chartBranchArrows[0] : null;\n  }\n\n  // used when dragging an arrow point that is connected to only one widget \n  updateDisconnectedArrow(arrow: ArrowWidget, widgets: Record<string, Widget>, draggingPosition: Position) {\n    const startWidget = widgets[arrow.start || \"\"];\n    const endWidget = widgets[arrow.end || \"\"];\n    \n    const connectedWidget = startWidget ? startWidget : endWidget;\n    if (!connectedWidget) return;\n\n    const startPosition: Position = startWidget ? {x: startWidget.x, y: startWidget.y } : draggingPosition;\n    const endPosition: Position = endWidget ? {x: endWidget.x, y: endWidget.y } : draggingPosition;\n\n    // initial dummy values\n    let points: Point[] = [{type: \"right\", x: 0, y: 0}, {type: \"left\", x: 1, y: 0}];\n\n    // stick to your branch side\n    if(!this.state.settings.stickToConvergentWidgetSide || arrow.arrowType !== \"chartBranch\") {\n      const isHorizontalStart = Math.abs((startPosition.x - endPosition.x) / (startPosition.y - endPosition.y)) > 1;\n      // change connections depending on positioning (and wich side is the connectedWidget)\n      if(isHorizontalStart) {\n        if(connectedWidget.x + connectedWidget.width + TOLERANCE < draggingPosition.x) {\n          points[0].type = arrow.startPoint || (startWidget ? \"right\" : \"left\");\n          points[1].type = arrow.endPoint || (startWidget ? \"left\" : \"right\");\n        } else {\n          points[0].type = arrow.startPoint || (startWidget ? \"left\" : \"right\");\n          points[1].type = arrow.endPoint || (startWidget ? \"right\" : \"left\");\n        }\n      } else {\n        if (connectedWidget.y + connectedWidget.height + TOLERANCE < draggingPosition.y) {\n          points[0].type = arrow.startPoint || (startWidget ? \"bottom\" : \"top\");\n          points[1].type = arrow.endPoint || (startWidget ? \"top\" : \"bottom\");\n        } else {\n          points[0].type = arrow.startPoint || (startWidget ? \"top\" : \"bottom\");\n          points[1].type = arrow.endPoint || (startWidget ? \"bottom\" : \"top\");\n        }\n      }\n      points[0] = startWidget ? this.getWidgetSideMidPosition(points[0], startWidget) : {...points[0], x: draggingPosition.x, y: draggingPosition.y};\n      points[1] = endWidget ? this.getWidgetSideMidPosition(points[1], endWidget) : {...points[1], x: draggingPosition.x, y: draggingPosition.y};\n      arrow.points = points;\n\n      const chartBranchArrow = this.getSharedChartBranchArrow(arrow, widgets);\n      \n      if(chartBranchArrow && chartBranchArrow.chartBranch) {\n        arrow.arrowType = 'chartBranch';\n        console.log('become part of an existing chartBranch');\n        // become part of an existing chartBranch\n        if(chartBranchArrow.chartBranch.type === \"oneToOne\") {\n          // if we are just adding the 2nd arrow to this chartBranch, update type and convergenceSide beforehand\n          if(chartBranchArrow.start === arrow.start ){\n            chartBranchArrow.chartBranch.type = \"oneToMany\";\n            chartBranchArrow.chartBranch.convergenceSide = arrow.points[0].type;\n          } else {\n            chartBranchArrow.chartBranch.type = \"manyToOne\";\n            chartBranchArrow.chartBranch.convergenceSide = arrow.points[1].type;\n          }\n        }\n        arrow.chartBranch = Object.assign({}, chartBranchArrow.chartBranch);\n      }\n    }\n  }\n\n  // updates arrow points (start/end) in both position and type\n  updateArrow(arrow: ArrowWidget, widgets: Record<string, Widget>, snappingPoint?: PointType | \"auto\", isStart?: boolean) {\n    const startWidget = widgets[arrow.start || \"\"];\n    const endWidget = widgets[arrow.end || \"\"];\n    // initial dummy values\n    let points: Point[] = [{type: \"right\", x: 0, y: 0}, {type: \"left\", x: 1, y: 0}];\n    \n    if(arrow.points.length === 2) {\n      points = arrow.points;\n    }\n    \n    if (isStart && snappingPoint) {\n      arrow.startPoint = snappingPoint !== \"auto\" ? snappingPoint : null;\n      arrow.arrowType = 'initial';\n      arrow.chartBranch = null;\n    } else if (snappingPoint) {\n      arrow.endPoint = snappingPoint !== \"auto\" ? snappingPoint : null;\n      arrow.arrowType = 'initial';\n      arrow.chartBranch = null;\n    }\n    // stick to your branch side\n    if(!this.state.settings.stickToConvergentWidgetSide || arrow.arrowType !== \"chartBranch\") {\n      const isHorizontalStart = Math.abs((startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)) > 1;\n      // change connections depending on positioning\n      if(isHorizontalStart) {\n        if (startWidget.x + startWidget.width + TOLERANCE < endWidget.x) {\n          points[0].type = arrow.startPoint || \"right\";\n          points[1].type = arrow.endPoint || \"left\";\n        } else {\n          points[0].type = arrow.startPoint || \"left\";\n          points[1].type = arrow.endPoint || \"right\";\n        }\n      } else {\n        if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n          points[0].type = arrow.startPoint || \"bottom\";\n          points[1].type = arrow.endPoint || \"top\";\n        } else {\n          points[0].type = arrow.startPoint || \"top\";\n          points[1].type = arrow.endPoint || \"bottom\";\n        }\n      }\n      points[0] = this.getWidgetSideMidPosition(points[0], startWidget);\n      points[1] = this.getWidgetSideMidPosition(points[1], endWidget);\n      arrow.points = points;\n      \n      // check if being a chartSide arrow\n      if(this.isChartSideArrow(arrow, widgets)) {\n        console.log('IS CHART SIDE ARROW');\n        this.updateArrowChartSide(arrow, startWidget, endWidget);\n      }\n      \n      // check if being part of a chartBranch\n      this.setArrowChartBranch(arrow, widgets, true);\n    }\n    \n    // update chartBranch arrows\n    // this is mainly used for a branched arrow whose widget is \"behind\" the branch fixed position \n    if(arrow.chartBranch) {\n      // on \"oneOnOne\" we consider the start widget as the convergent one\n      const convergesOnEnd = arrow.chartBranch.type === \"manyToOne\"; \n      let convergencePoint = convergesOnEnd ? arrow.points[1] : arrow.points[0];\n      let nonConvergencePoint = convergesOnEnd ? arrow.points[0] : arrow.points[1];\n      const convergentWidget = convergesOnEnd ? endWidget : startWidget;\n      const nonConvergentWidget = convergesOnEnd ? startWidget : endWidget;\n      \n      convergencePoint = this.getWidgetSideMidPosition(convergencePoint, convergentWidget);\n      nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n    \n      if(toOrientation(arrow.chartBranch.convergenceSide) === \"horizontal\") {\n        // if inside, use 2-segment arrow\n        if(arrow.chartBranch.position >= nonConvergentWidget.x && arrow.chartBranch.position <= nonConvergentWidget.x + nonConvergentWidget.width) {\n          nonConvergencePoint.x = arrow.chartBranch.position;\n          nonConvergencePoint.y = (nonConvergentWidget.y + nonConvergentWidget.height/2) > convergencePoint.y ? nonConvergentWidget.y : nonConvergentWidget.y + nonConvergentWidget.height;\n        // otherwise use regular 3-segment arrow but make sure it connects to the correct side\n        } else {\n          nonConvergencePoint.type = arrow.chartBranch.position < nonConvergentWidget.x ? \"left\" : \"right\";\n          nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n        }\n      } else {  // vertical\n        // if inside, use 2-segment arrow\n        if(arrow.chartBranch.position >= nonConvergentWidget.y && arrow.chartBranch.position <= nonConvergentWidget.y + nonConvergentWidget.height) {\n          nonConvergencePoint.x = (nonConvergentWidget.x + nonConvergentWidget.width/2) > convergencePoint.x ? nonConvergentWidget.x : nonConvergentWidget.x + nonConvergentWidget.width;\n          nonConvergencePoint.y = arrow.chartBranch.position;\n        // otherwise use regular 3-segment arrow but make sure it connects to the correct side\n        } else {\n          nonConvergencePoint.type = arrow.chartBranch.position < nonConvergentWidget.y ? \"top\" : \"bottom\";\n          nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n        }\n      }\n\n      arrow.points[0] = convergesOnEnd ? nonConvergencePoint : convergencePoint;\n      arrow.points[1] = convergesOnEnd ? convergencePoint : nonConvergencePoint;\n    }\n  }\n  \n  isChartSideArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    // can't be chartSide if there is any chartBranch on current side\n    if(this.getSharedChartBranchArrow(arrow, widgets)) return false;\n    // can't be chartSide if their point were intentionally positioned\n    if (arrow.startPoint || arrow.endPoint) return false;\n\n    return ((arrow.initialIsHorizontal && (arrow.points[0].type === \"top\" || arrow.points[0].type === \"bottom\")) ||\n    (!arrow.initialIsHorizontal && (arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\")));\n  }\n\n  // returns true if using intersection chartSide\n  updateArrowChartSide(arrow: ArrowWidget, startWidget: Widget, endWidget: Widget) {\n    // if widgets limits are intersecting, use chartSide connector\n    if(arrow.initialIsHorizontal) {\n      const middleX = this.getIntersectionMiddle(startWidget.x, startWidget.width, endWidget.x, endWidget.width);\n      if(middleX) {\n        arrow.points[0].x = middleX;\n        arrow.points[1].x = middleX;\n        return true;\n      }\n    } else {\n      const middleY = this.getIntersectionMiddle(startWidget.y, startWidget.height, endWidget.y, endWidget.height);\n      if(middleY) {\n        arrow.points[0].y = middleY;\n        arrow.points[1].y = middleY;\n        return true;\n      }\n    }\n\n    // if there is no intersection, use original axis side\n    if(arrow.initialIsHorizontal) {\n      arrow.points[0].type = endWidget.x > startWidget.x + (startWidget.width / 2) ? \"right\" : \"left\";\n    } else {\n      arrow.points[0].type = endWidget.y > startWidget.y + (startWidget.height / 2) ? \"bottom\" : \"top\";\n    }\n    arrow.points[0] = this.getWidgetSideMidPosition(arrow.points[0], startWidget);\n    \n    const startWidgetCenter = {x: startWidget.x + (startWidget.width/2), y: startWidget.y + (startWidget.height/2)};\n    const endWidgetCenter = {x: endWidget.x + (endWidget.width/2), y: endWidget.y + (endWidget.height/2)};\n    const distX = Math.abs(startWidgetCenter.x - endWidgetCenter.x) - (startWidget.width/2 + endWidget.width/2);\n    const distY = Math.abs(startWidgetCenter.y - endWidgetCenter.y) - (startWidget.height/2 + endWidget.height/2);\n    const widgetsTooClose = arrow.initialIsHorizontal ? distX <= ARROW_MARGIN : distY <= ARROW_MARGIN;\n    \n    // if widgets are too close, use 2-segments arrow\n    if(widgetsTooClose) {\n      // never closer than 20px from origin and never less than 10px from target side\n      if(arrow.initialIsHorizontal) {\n        arrow.points[1].type = endWidget.y > arrow.points[0].y ? \"top\" : \"bottom\";\n        let distXToCenter = startWidget.width/2 + Math.max(distX + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n        arrow.points[1].x = startWidgetCenter.x + (arrow.points[0].type === \"right\" ? distXToCenter : -distXToCenter);\n        arrow.points[1].y = arrow.points[1].type === \"top\" ? endWidget.y : endWidget.y + endWidget.height;\n      } else {\n        arrow.points[1].type = endWidget.x > arrow.points[0].x ? \"left\" : \"right\";\n        let distYToCenter = startWidget.height/2 + Math.max(distY + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n        arrow.points[1].x = arrow.points[1].type === \"left\" ? endWidget.x : endWidget.x + endWidget.width;\n        arrow.points[1].y = startWidgetCenter.y + (arrow.points[0].type === \"bottom\" ? distYToCenter : -distYToCenter);\n      }\n    // otherwise use regular 3-segments arrow\n    } else {\n      if(arrow.initialIsHorizontal) {\n        \tarrow.points[1].type = arrow.points[0].type === \"right\" ? \"left\" : \"right\";\n      } else {\n        arrow.points[1].type = arrow.points[0].type === \"bottom\" ? \"top\" : \"bottom\";\n      }\n      arrow.points[1] = this.getWidgetSideMidPosition(arrow.points[1], endWidget);\n    }\n\n    return false;\n  }\n\n  // returns if any widgets are at \"distance\" or lower in the requested axis\n  widgetsTooClose(a: Widget, b: Widget, distance: number, horizontal: boolean) {\n    const aCenter = {x: a.x + (a.width/2), y: a.y + (a.height/2)};\n    const bCenter = {x: b.x + (b.width/2), y: b.y + (b.height/2)};\n    if(horizontal) {\n      const distX = Math.abs(aCenter.x - bCenter.x) - (a.width/2 + b.width/2);\n      return distX <= distance;\n    }\n    const distY = Math.abs(aCenter.y - bCenter.y) - (a.height/2 + b.height/2);\n    return distY <= distance;\n  }\n\n  // returns the middle point of an intersection\n  getIntersectionMiddle(min1: number, size1: number, min2: number, size2: number) {\n    const max1 = min1 + size1;\n    const max2 = min2 + size2;\n\n    // TODO: none of this works when moving endWidget\n    // TODO: make sure this works with different shaped widgets\n    // if((this.between(min1, min2, max2) && this.between(max1, min2, max2)) ||\n    //    (this.between(min2, min1, max1) && this.between(max2, min1, max1))) {\n    if((min1 === min2 && max1 === max2) ||\n      (min1 > min2 && min1 < max2)) {\n      const intersection = max2 - min1;\n      if(intersection <= ARROW_MARGIN * 2) return null;\n      \n      return min1 + (intersection / 2);\n    } else if(max1 > min2 && max1 < max2) {\n      const intersection = max1 - min2;\n      if(intersection <= ARROW_MARGIN * 2) return null;\n\n      return max1 - (intersection / 2);\n    }\n\n    // no intersection\n    return null;\n  }\n\n  between(value: number, min: number, max: number) {\n    return value>min && value<max;\n  }\n  \n  getWidgetSideMidPosition(point: Point, widget: Widget) {\n    let newPoint: Point = {type: point.type, x: 0, y: 0};\n    switch(point.type) {\n      case \"top\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y;\n        break;\n      case \"right\":\n        newPoint.x = widget.x + widget.width;\n        newPoint.y = widget.y + widget.height / 2;\n        break;\n      case \"bottom\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y + widget.height;\n        break;\n      case \"left\":\n        newPoint.x = widget.x;\n        newPoint.y = widget.y + widget.height / 2;\n        break;\n    }\n\n    return newPoint;\n  }\n\n  render() {\n    const { cursor, selected, widgets } = this.state;\n    return (\n      <div>\n        <div\n          id=\"canvas\"\n          style={{ cursor }}\n          className={`App ${cursor === 'crosshair' ? 'connector-mode' : ''}`}\n          tabIndex={1}\n          onDoubleClick={this.handleDoubleClick}\n          onKeyDown={this.handleKeyDown}\n          onMouseMove={this.handleDrag}\n          onMouseDown={this.handleMouseDown}\n          onMouseUp={this.handleMouseUp}\n          ref={this.handleRef}\n          >\n          {Object.values(widgets).map((w) => {\n            if (w.type === \"sticky\") {\n              return (\n                <Sticky\n                  cursor={cursor}\n                  onMouseDown={this.handleStickyMouseDown}\n                  onMouseUp={this.handleStickyMouseUp}\n                  onDragStart={this.handleWidgetDragStart}\n                  onMouseHover={this.handleMouseHoverSticky}\n                  onMouseLeave={this.handleMouseLeaveSticky}\n                  selected={!!selected?.includes(w.id)}\n                  widget={w}\n                  key={w.id}\n                />\n                );\n            }\n            \n            if (w.type === \"arrow\") {\n              return <Arrow\n                widget={w} key={w.id}\n                onDragPointStart={this.handleArrowPointDragStart}\n                onDragSegmentEnd={this.handleDragSegmentEnd}\n              />;\n            }\n            \n            return null;\n          })}\n        </div>\n        <div id=\"settings\" style={settingsStyle}>\n          <Checkbox\n            label=\"Stick To Convergent Widget Side\"\n            onCheckedChange={(checked) => this.setState({settings: { stickToConvergentWidgetSide: checked }})} />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}