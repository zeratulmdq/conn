{"version":3,"sources":["widgets/Sticky.tsx","widgets/Arrow.tsx","settings/Checkbox.tsx","types.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleClick","e","props","onClick","widget","id","handleDragStart","onDragStart","handleMouseHover","onMouseHover","handleMouseLeave","onMouseLeave","this","cursor","selected","x","y","width","height","onMouseDown","onMouseMove","style","top","left","border","className","React","Component","Arrow","position","pointerEvents","xmlns","version","points","chartBranch","start","end","isHorizontalStart","type","isHorizontalEnd","d","stroke","strokeWidth","fill","cx","cy","r","p1","p2","p3","d1","d2","midDistance","segment2Position","convergenceTarget","convergenceSide","p4","d3","pathGenerator","PureComponent","Checkbox","state","checked","handleOnChange","setState","prevState","onCheckedChange","onChange","defaultChecked","label","stickyFactory","spec","uuid","arrowFactory","arrowType","initialIsHorizontal","toOrientation","settingsStyle","borderStyle","backgroundColor","padding","App","ref","settings","stickToConvergentWidgetSide","initialId","lastX","lastY","widgets","preventDefault","stopPropagation","cancelArrowCreation","handleStickyClick","draggingArrow","startWidget","endWidget","Object","values","find","w","isHorizontalConnection","Math","abs","updateArrow","mousePosition","clientX","clientY","arrow","updateDisconnectedArrow","handleDoubleClick","stickyWidth","ctrlKey","s","handleDrag","draggingWidget","connectedArrows","filter","reduce","acc","cur","handleMouseHoverSticky","handleMouseLeaveSticky","handleWidgetDragStart","button","handleKeyDown","key","newCursor","prevWidgets","forEach","handleMouseDown","handleMouseUp","map","isChartSideArrow","updateArrowChartSide","setArrowChartBranch","handleRef","focus","chartBranchArrow","getSharedChartBranchArrow","assign","chartBranchArrows","length","draggingPosition","connectedWidget","startPosition","endPosition","getWidgetSideMidPosition","convergesOnEnd","convergencePoint","nonConvergencePoint","convergentWidget","nonConvergentWidget","middleX","getIntersectionMiddle","middleY","startWidgetCenter","endWidgetCenter","distX","distY","distXToCenter","max","distYToCenter","a","b","distance","horizontal","aCenter","bCenter","min1","size1","min2","size2","max1","max2","intersection","ARROW_MARGIN","value","min","point","newPoint","tabIndex","onDoubleClick","onKeyDown","onMouseUp","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.4c79f609.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onClick: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDragStart: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onMouseHover: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onMouseLeave: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  selected: boolean;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.Component<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onClick, widget } = this.props;\n    onClick(widget.id, e);\n  };\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onDragStart, widget } = this.props;\n    onDragStart(widget.id, e);\n  };\n  \n  handleMouseHover = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onMouseHover, widget } = this.props;\n    onMouseHover(widget.id, e);\n  };\n\n  handleMouseLeave = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onMouseLeave, widget } = this.props;\n    onMouseLeave(widget.id, e);\n  };\n\n  render() {\n    const {\n      cursor,\n      selected,\n      widget: { x, y , width, height},\n    } = this.props;\n    return (\n      <div\n        onClick={this.handleClick}\n        onMouseDown={this.handleDragStart}\n        onMouseMove={this.handleMouseHover}\n        onMouseLeave={this.handleMouseLeave}\n        style={{\n          top: y,\n          left: x,\n          width: width,\n          height: height,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n          border: selected ? \"2px solid blue\" : \"none\",\n        }}\n        className=\"Sticky\"\n      />\n    );\n  }\n}\n\nexport default Sticky;\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport { ArrowWidget, ChartBranch, Point } from \"../types\";\n\ninterface PropTypes {\n  widget: ArrowWidget;\n}\n\nconst pathGenerator = (points: Point[], chartBranch: ChartBranch | null) => {\n  const start = points[0];\n  const end = points[1];\n  const isHorizontalStart = start.type === \"right\" || start.type === \"left\";\n  const isHorizontalEnd = end.type === \"right\" || end.type === \"left\";\n\n  // 1-segment straight line\n  if((isHorizontalStart && start.y === end.y) ||\n    (!isHorizontalStart && start.x === end.x)) {\n      const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n      return [\n        <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n        <circle\n          cx={`${end.x}`}\n          cy={`${end.y}`}\n          r=\"5\"\n          stroke=\"#5cb85c\"\n          fill=\"#5cb85c\"\n        ></circle>,\n      ];\n  }\n\n  // 2-segments line\n  if(isHorizontalStart !== isHorizontalEnd) {\n    const p1 = `${start.x} ${start.y}`;\n    const p2 = isHorizontalStart ? `${end.x} ${start.y}` : `${start.x} ${end.y}`;\n    const p3 = `${end.x} ${end.y}`;\n    \n    const d1 = `M ${p1} L ${p2}`;\n    const d2 = `M ${p2} L ${p3}`;\n    return [\n      <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <circle\n        cx={`${end.x}`}\n        cy={`${end.y}`}\n        r=\"5\"\n        stroke=\"#5cb85c\"\n        fill=\"#5cb85c\"\n      ></circle>,\n    ];\n  }\n\n  // 3-segments line\n  const midDistance = isHorizontalStart ? (end.x - start.x) / 2 : (end.y - start.y) / 2;\n  let segment2Position = isHorizontalStart ? start.x + midDistance: start.y + midDistance;\n  if(chartBranch)\n  {\n    const convergenceTarget = chartBranch.type === \"manyToOne\" ? end : start;\n    if(chartBranch.convergenceSide === convergenceTarget.type) {\n      segment2Position = chartBranch.position;\n    }\n  }\n\n  const p1 = `${start.x} ${start.y}`;\n  const p2 = isHorizontalStart ? `${segment2Position} ${start.y}` : ` ${start.x} ${segment2Position}`;\n  const p3 = isHorizontalStart ? `${segment2Position} ${end.y}` : ` ${end.x} ${segment2Position}`;\n  const p4 = `${end.x} ${end.y}`;\n\n  const d1 = `M ${p1} L ${p2}`;\n  const d2 = `M ${p2} L ${p3}`;\n  const d3 = `M ${p3} L ${p4}`;\n\n  return [\n    <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <circle\n      cx={`${end.x}`}\n      cy={`${end.y}`}\n      r=\"5\"\n      stroke=\"#5cb85c\"\n      fill=\"#5cb85c\"\n    ></circle>,\n  ];\n};\n\nclass Arrow extends React.PureComponent<PropTypes> {\n  render() {\n    return (\n      <svg\n        style={{ position: \"absolute\", top: 0, left: 0, pointerEvents: \"none\" }}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        version=\"1.1\"\n      >\n        {pathGenerator(this.props.widget.points, this.props.widget.chartBranch)}\n      </svg>\n    );\n  }\n}\n\nexport default Arrow;","import React from \"react\";\r\n\r\ninterface PropTypes {\r\n  label: string;\r\n  onCheckedChange: (checked: boolean) => void;\r\n}\r\n\r\ninterface State {\r\n  checked: boolean;\r\n}\r\n\r\nclass Checkbox extends React.PureComponent<PropTypes, State> {\r\n  state: State = {\r\n    checked: false,\r\n  };\r\n\r\n  handleOnChange = (e: React.ChangeEvent<HTMLInputElement>) => { \r\n    this.setState((prevState) => {\r\n      const checked = !prevState.checked;\r\n      this.props.onCheckedChange(checked);\r\n      return {\r\n        checked\r\n      };\r\n    });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div style={{height: \"auto\"}}>\r\n        <label>\r\n          <input\r\n            type=\"checkbox\"\r\n            style={{width: 15, height: 15}}\r\n            onChange={this.handleOnChange}\r\n            defaultChecked={this.state.checked} />\r\n          {this.props.label}\r\n        </label>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Checkbox;","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\nexport type Orientation = \"horizontal\" | \"vertical\";\nexport type ChartBranchType = \"oneToOne\" | \"oneToMany\" | \"manyToOne\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type: PointType;\n}\n\nexport interface Position {\n  x: number;\n  y: number;\n}\n\nexport interface ChartBranch {\n  position: number; // fixed position where arrows share the 2nd branch segment\n  convergenceSide: PointType;  // side of the widget where the arrows converge (might be start or end widget depending of ChartBranchType)\n  type: ChartBranchType;\n}\n\n// initial: initial simple arrow, centered to the connected widgets on both ends, bent into 3 segments having the same length in both parallel segments.\n// chartBranch: created from an 'initial' arrow, centered to the connected widgets on both ends, bent into 3 segments, can share inital segment with other 'chartBranch' arrows, 1st segment size stays put.\n// chartSide: created from an 'initial' arrow, moved to the side of a group of 'chartBranch' arrows and can be on any point of both connected widgets.\nexport type ArrowType = \"initial\" | \"chartBranch\" | \"chartSide\";\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  end: string | null;\n  arrowType: ArrowType;\n  chartBranch: ChartBranch | null;\n  initialIsHorizontal: boolean;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: spec.height ?? 100,\n  width: spec.width ?? 100,\n  type: \"sticky\",\n  x: (spec.x || 0) - 50,\n  y: (spec.y || 0) - 50,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n  arrowType: spec.arrowType || \"initial\",\n  chartBranch: null,\n  initialIsHorizontal: spec.initialIsHorizontal || true,\n});\n\nexport const toOrientation = (type: PointType) : Orientation => {\n  return type === \"left\" || type === \"right\" ? \"horizontal\" : \"vertical\";\n}\n","import React, { CSSProperties } from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport Arrow from \"./widgets/Arrow\";\nimport Checkbox from \"./settings/Checkbox\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n  Position,\n  toOrientation,\n  ChartBranch,\n} from \"./types\";\n\nexport const TOLERANCE = 10;\nexport const ARROW_MARGIN = 10;\nexport const TWO_SEGMENT_ARROW_MIN = 20;\n\nexport const settingsStyle: React.CSSProperties = {\n  position: \"absolute\",\n  top: 0,\n  width:\"auto\",\n  height: \"auto\",\n  borderStyle: \"solid\",\n  backgroundColor: \"lightgray\",\n  padding: 10,\n};\n\ninterface State {\n  settings:{\n    stickToConvergentWidgetSide: boolean;\n  };\n  cursor: React.CSSProperties[\"cursor\"];\n  dragging: string | null;\n  initialId: string | null;\n  initialX: number | null;\n  initialY: number | null;\n  lastX: number | null;\n  lastY: number | null;\n  selected: string | null;\n  widgets: Record<string, Widget>;\n}\n\nclass App extends React.Component<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    settings :{\n      stickToConvergentWidgetSide: false,\n    },\n    cursor: \"auto\",\n    dragging: null,\n    initialId: null,\n    initialX: null,\n    initialY: null,\n    lastX: null,\n    lastY: null,\n    selected: null,\n    widgets: {},\n  };\n\n  cancelArrowCreation() {\n    \n    this.setState((prevState) => {\n      if(prevState.dragging) {\n        // delete dragging arrow if any\n        const draggingWidget = { ...prevState.widgets[prevState.dragging] };\n        if(draggingWidget.type === \"arrow\") {\n          const prevWidgets = prevState.widgets;\n          delete prevWidgets[draggingWidget.id];\n          return {\n            ...prevState,\n            dragging: null,\n            initialId: null,\n            cursor: \"auto\",\n            widgets: { ...prevWidgets },\n          }\n        }\n      }\n\n      return {\n        ...prevState,\n        dragging: null,\n        initialId: null,\n        cursor: \"auto\",\n      }\n    });\n  }\n  \n  handleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (this.state.initialId) {\n      this.cancelArrowCreation();\n    }\n  }\n\n  handleStickyClick = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    if (this.state.initialId === id) {\n      this.cancelArrowCreation();\n      return;\n    }\n\n    if (this.state.cursor !== \"crosshair\")\n      return;\n\n    // start arrow creation\n    if (!this.state.initialId) {\n      const mousePosition: Position = {x: e.clientX, y: e.clientY };\n      // this.setState({initialId: id});\n\n      // create Arrow for dragging without end widget\n      this.setState((prevState) => {\n        const arrow = {\n          ...arrowFactory({ start: id, end: null }),\n        };\n\n        this.updateDisconnectedArrow(arrow, prevState.widgets, mousePosition);\n\n        return {\n          ...prevState,\n          initialId: id,\n          widgets: {\n            ...prevState.widgets,\n            [arrow.id]: arrow,\n          },\n          dragging: arrow.id,\n          initialX: mousePosition.x,\n          initialY: mousePosition.y,\n          lastX: mousePosition.x,\n          lastY: mousePosition.y,\n        };\n      });\n\n      return;\n    }\n    \n    this.setState((prevState) => {\n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      const draggingArrow = { ...prevState.widgets[prevState.dragging] } as ArrowWidget;\n      const startWidget = prevState.widgets[draggingArrow.start ?? id];\n      const endWidget = prevState.widgets[draggingArrow.end ?? id];\n\n      // avoid duplicate arrow (same start and end)\n      const duplicateArrow = Object.values(prevState.widgets).find(w => w.type===\"arrow\" && w.id !== draggingArrow.id && w.start === startWidget.id && w.end === endWidget.id);\n      if(duplicateArrow) {\n        return { ...prevState }\n      }\n      \n      // update Arrow start/end and connect it to both widgets\n      const isHorizontalConnection = Math.abs((startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)) > 1;\n      draggingArrow.start = startWidget.id;\n      draggingArrow.end = endWidget.id;\n      draggingArrow.initialIsHorizontal = isHorizontalConnection;\n\n      this.updateArrow(draggingArrow, prevState.widgets);\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        dragging: null,\n        initialId: null,\n        widgets: {\n          ...prevState.widgets,\n          [draggingArrow.id]: draggingArrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    // create rectangular stickies while holding CTRL down\n    const stickyWidth = e.ctrlKey ? 150 : 100;\n    const s = stickyFactory({ x: e.clientX, y: e.clientY, width: stickyWidth });\n    this.setState((prevState) => ({\n      selected: s.id,\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (e: React.MouseEvent<HTMLDivElement>) => {\n    const mousePosition: Position = {x: e.clientX, y: e.clientY };\n\n    this.setState((prevState) => {\n      if (!prevState.dragging || !prevState.lastX || !prevState.lastY)\n        return { ...prevState };\n      \n      const draggingWidget = { ...prevState.widgets[prevState.dragging] };\n      if(draggingWidget.type === \"sticky\") {\n        // move dragged sticky\n        draggingWidget.x = draggingWidget.x + mousePosition.x - prevState.lastX;\n        draggingWidget.y = draggingWidget.y + mousePosition.y - prevState.lastY;\n\n        // update connected arrows\n        const connectedArrows = Object.values(prevState.widgets)\n        .filter(\n          (w) =>\n            w.type === \"arrow\" &&\n            (w.start === prevState.dragging || w.end === prevState.dragging)\n        )\n        .reduce((acc, cur) => {\n          const arrow = cur as ArrowWidget;\n          this.updateArrow(arrow, prevState.widgets);\n          \n          return {\n            ...acc,\n            [arrow.id]: {\n              ...arrow,\n            },\n          };\n        }, {} as Record<string, Widget>);\n  \n        return {\n          lastX: mousePosition.x,\n          lastY: mousePosition.y,\n          widgets: {\n            ...prevState.widgets,\n            [draggingWidget.id]: draggingWidget,\n            ...connectedArrows,\n          },\n        };\n      } else if(draggingWidget.type === \"arrow\") {\n        // update arrow dragged end\n        this.updateDisconnectedArrow(draggingWidget, prevState.widgets, mousePosition);\n        \n        return {\n          lastX: mousePosition.x,\n          lastY: mousePosition.y,\n          widgets: {\n            ...prevState.widgets,\n            [draggingWidget.id]: draggingWidget,\n          },\n        };\n      }\n\n      return { ...prevState };\n    });\n  };\n\n  handleMouseHoverSticky = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const mousePosition: Position = {x: e.clientX, y: e.clientY };\n    \n    this.setState((prevState) => {\n      if (!prevState.dragging || !prevState.lastX || !prevState.lastY)\n        return { ...prevState };\n      \n      // stick to widget when hovering while dragging\n      const draggingWidget = { ...prevState.widgets[prevState.dragging] };\n      if(draggingWidget.type === \"arrow\" && draggingWidget.start !== id && draggingWidget.end !== id) {\n        // connect to widget and update arrow\n        draggingWidget.start = draggingWidget.start ?? id;\n        draggingWidget.end = draggingWidget.end ?? id;\n        this.updateArrow(draggingWidget, prevState.widgets);\n        \n        return {\n          lastX: mousePosition.x,\n          lastY: mousePosition.y,\n          widgets: {\n            ...prevState.widgets,\n            [draggingWidget.id]: draggingWidget,\n          },\n        };\n      }\n      return { ...prevState };\n    });\n  }\n\n  handleMouseLeaveSticky = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const mousePosition: Position = {x: e.clientX, y: e.clientY };\n    \n    this.setState((prevState) => {\n      if (!prevState.dragging || !prevState.lastX || !prevState.lastY)\n        return { ...prevState };\n      \n      const draggingWidget = { ...prevState.widgets[prevState.dragging] };\n      if(draggingWidget.type === \"arrow\" && draggingWidget.start && draggingWidget.end && (draggingWidget.start === id || draggingWidget.end === id)) {\n        // disconnect from widget and update arrow\n        draggingWidget.start = draggingWidget.start === id ? null: draggingWidget.start;\n        draggingWidget.end = draggingWidget.end === id ? null : draggingWidget.end;\n        this.updateDisconnectedArrow(draggingWidget, prevState.widgets, mousePosition);\n        \n        return {\n          lastX: mousePosition.x,\n          lastY: mousePosition.y,\n          widgets: {\n            ...prevState.widgets,\n            [draggingWidget.id]: draggingWidget,\n          },\n        };\n      }\n      return { ...prevState };\n    });\n  }\n\n  handleWidgetDragStart = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX: initialX, clientY: initialY } = e;\n    e.stopPropagation();\n\n    if (e.button !== 0)\n      return;\n\n    if(this.state.dragging)\n      return;\n\n    this.setState({\n      dragging: id,\n      selected: id,\n      initialX: initialX,\n      initialY: initialY,\n      lastX: initialX,\n      lastY: initialY,\n    });\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if(e.key === \"c\") {\n      const newCursor = this.state.cursor === \"auto\" ? \"crosshair\" : \"auto\";\n      if(newCursor === \"auto\") {\n        this.cancelArrowCreation();\n      } else {\n        this.setState({\n          cursor: newCursor,\n        });\n      }\n    }\n\n    if ((e.key === \"Backspace\" || e.key === \"Delete\") && this.state.selected) {\n      this.setState((prevState) => {\n        const id = prevState.selected || \"\";\n        const prevWidgets = prevState.widgets;\n        delete prevWidgets[id];\n\n        Object.values(prevWidgets).forEach((w) => {\n          if (w.type === \"arrow\" && (w.start === id || w.end === id))\n            delete prevWidgets[w.id];\n        });\n        return {\n          ...prevState,\n          selected: null,\n          widgets: { ...prevWidgets },\n        };\n      });\n    }\n  };\n\n  handleMouseDown = () => {\n    this.setState({ selected: null });\n  };\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    this.setState((prevState) => {\n      \n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      // ignore MouseUp when dragging arrows\n      const draggingWidget = { ...prevState.widgets[prevState.dragging] };\n      if(draggingWidget.type === \"arrow\") {\n        return { ...prevState };\n      }\n      \n      const connectedArrows = Object.values(prevState.widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          (w.start === prevState.dragging || w.end === prevState.dragging)\n      ).map(w=> w as ArrowWidget)\n      .reduce((acc, arrow) => {\n\n        // stick to your branch side\n        if(!prevState.settings.stickToConvergentWidgetSide || arrow.arrowType !== \"chartBranch\") {\n          if(this.isChartSideArrow(arrow, prevState.widgets)) {\n            const startWidget = prevState.widgets[arrow.start || \"\"] as StickyWidget;\n            const endWidget = prevState.widgets[arrow.end || \"\"] as StickyWidget;\n            if(this.updateArrowChartSide(arrow, startWidget, endWidget)) {\n              arrow.arrowType = \"chartSide\";\n            }\n          }\n          \n          // update chart branches state (for both start and end arrows)\n          this.setArrowChartBranch(arrow, prevState.widgets, false);\n        }\n          \n        // update initial axis\n        arrow.initialIsHorizontal = arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\";\n\n        return {\n          ...acc,\n          [arrow.id]: {\n            ...arrow,\n          },\n        };\n      }, {} as Record<string, Widget>);\n      \n      return {\n        dragging: null,\n        widgets: {\n          ...prevState.widgets,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleRef = (ref: HTMLDivElement) => {\n    this.ref = ref;\n    // start focused to listen for key presses\n    if(this.ref) {\n      this.ref.focus();\n    }\n  }\n\n  // finds if this arrow should be a part of a branchChart\n  setArrowChartBranch(arrow: ArrowWidget, widgets: Record<string, Widget>, dragging: boolean) {\n    if(!this.state.settings.stickToConvergentWidgetSide && arrow.chartBranch) {\n      // don't recalculate if chartBranchSide didn't change\n      let convergencePoint = arrow.chartBranch.type === \"manyToOne\" ? arrow.points[1] : arrow.points[0];\n      if(convergencePoint.type === arrow.chartBranch.convergenceSide)\n        return;\n    }\n\n    const chartBranchArrow = this.getSharedChartBranchArrow(arrow, widgets);\n    // don't force chartBranching while dragging on an empty side of the origin/end widget\n    if(dragging && !chartBranchArrow) {\n      arrow.chartBranch = null;\n      return;\n    }\n  \n    // don't set arrowType while dragging (wait until mouseUp)\n    if(!dragging) {\n      arrow.arrowType = \"chartBranch\";\n    }\n    \n    if(chartBranchArrow && chartBranchArrow.chartBranch) {\n      // become part of an existing chartBranch\n      if(chartBranchArrow.chartBranch.type === \"oneToOne\") {\n        // if we are just adding the 2nd arrow to this chartBranch, update type and convergenceSide beforehand\n        if(chartBranchArrow.start === arrow.start ){\n          chartBranchArrow.chartBranch.type = \"oneToMany\";\n          chartBranchArrow.chartBranch.convergenceSide = arrow.points[0].type;\n        } else {\n          chartBranchArrow.chartBranch.type = \"manyToOne\";\n          chartBranchArrow.chartBranch.convergenceSide = arrow.points[1].type;\n        }\n      }\n      arrow.chartBranch = Object.assign({}, chartBranchArrow.chartBranch);\n    } else {\n      // new lonely charBranch arrow\n      let chartBranch: ChartBranch = {\n        position: 0,\n        convergenceSide: arrow.points[0].type,\n        type: \"oneToOne\"\n      };\n      // on new branch, set 2nd segment position to half the distance in X or Y depending on orientation \n      if(toOrientation(chartBranch.convergenceSide) === \"horizontal\") {\n        chartBranch.position = arrow.points[0].x + ((arrow.points[1].x - arrow.points[0].x) / 2);\n      } else {\n        chartBranch.position = arrow.points[0].y + ((arrow.points[1].y - arrow.points[0].y) / 2);\n      }\n      arrow.chartBranch = chartBranch;\n    }\n  }\n\n  // find another arrow that share same origin or end point and already has chartBranch defined\n  getSharedChartBranchArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    const chartBranchArrows = Object.values(widgets)\n    .filter(\n      (w) =>\n      w.type === \"arrow\" &&\n      w.id !== arrow.id &&\n      w.arrowType === \"chartBranch\" &&\n      w.chartBranch &&\n      ((w.start === arrow.start && w.points[0].type === arrow.points[0].type) ||\n       (w.end === arrow.end && w.points[1].type === arrow.points[1].type))\n    ).map(w => w as ArrowWidget);\n    \n    return chartBranchArrows.length > 0 ? chartBranchArrows[0] : null;\n  }\n\n  // used when dragging an arrow point that is connected to only one widget \n  updateDisconnectedArrow(arrow: ArrowWidget, widgets: Record<string, Widget>, draggingPosition: Position) {\n    const startWidget = widgets[arrow.start || \"\"];\n    const endWidget = widgets[arrow.end || \"\"];\n    \n    const connectedWidget = startWidget ? startWidget : endWidget;\n\n    const startPosition: Position = startWidget ? {x: startWidget.x, y: startWidget.y } : draggingPosition;\n    const endPosition: Position = endWidget ? {x: endWidget.x, y: endWidget.y } : draggingPosition;\n\n    // initial dummy values\n    let points: Point[] = [{type: \"right\", x: 0, y: 0}, {type: \"left\", x: 1, y: 0}];\n\n    const isHorizontalStart = Math.abs((startPosition.x - endPosition.x) / (startPosition.y - endPosition.y)) > 1;\n    // change connections depending on positioning (and wich side is the connectedWidget)\n    if(isHorizontalStart) {\n      if(connectedWidget.x + connectedWidget.width + TOLERANCE < draggingPosition.x) {\n        points[0].type = startWidget ? \"right\" : \"left\";\n        points[1].type = startWidget ? \"left\" : \"right\";\n      } else {\n        points[0].type = startWidget ? \"left\" : \"right\";\n        points[1].type = startWidget ? \"right\" : \"left\";\n      }\n    } else {\n      if (connectedWidget.y + connectedWidget.height + TOLERANCE < draggingPosition.y) {\n        points[0].type = startWidget ? \"bottom\" : \"top\";\n        points[1].type = startWidget ? \"top\" : \"bottom\";\n      } else {\n        points[0].type = startWidget ? \"top\" : \"bottom\";\n        points[1].type = startWidget ? \"bottom\" : \"top\";\n      }\n    }\n    points[0] = startWidget ? this.getWidgetSideMidPosition(points[0], startWidget) : {...points[0], x: draggingPosition.x, y: draggingPosition.y};\n    points[1] = endWidget ? this.getWidgetSideMidPosition(points[1], endWidget) : {...points[1], x: draggingPosition.x, y: draggingPosition.y};\n    arrow.points = points;\n  }\n\n  // updates arrow points (start/end) in both position and type\n  updateArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    const startWidget = widgets[arrow.start || \"\"];\n    const endWidget = widgets[arrow.end || \"\"];\n    \n    // initial dummy values\n    let points: Point[] = [{type: \"right\", x: 0, y: 0}, {type: \"left\", x: 1, y: 0}];\n    \n    if(arrow.points.length === 2) {\n      points = arrow.points;\n    }\n    \n    // stick to your branch side\n    if(!this.state.settings.stickToConvergentWidgetSide || arrow.arrowType !== \"chartBranch\") {\n      const isHorizontalStart = Math.abs((startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)) > 1;\n      // change connections depending on positioning\n      if(isHorizontalStart) {\n        if (startWidget.x + startWidget.width + TOLERANCE < endWidget.x) {\n          points[0].type = \"right\";\n          points[1].type = \"left\";\n        } else {\n          points[0].type = \"left\";\n          points[1].type = \"right\";\n        }\n      } else {\n        if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n          points[0].type = \"bottom\";\n          points[1].type = \"top\";\n        } else {\n          points[0].type = \"top\";\n          points[1].type = \"bottom\";\n        }\n      }\n      points[0] = this.getWidgetSideMidPosition(points[0], startWidget);\n      points[1] = this.getWidgetSideMidPosition(points[1], endWidget);\n      arrow.points = points;\n      \n      // check if being a chartSide arrow\n      if(this.isChartSideArrow(arrow, widgets)) {\n        this.updateArrowChartSide(arrow, startWidget, endWidget);\n      }\n      \n      // check if being part of a chartBranch\n      this.setArrowChartBranch(arrow, widgets, true);\n    }\n    \n    // update chartBranch arrows\n    // this is mainly used for a branched arrow whose widget is \"behind\" the branch fixed position \n    if(arrow.chartBranch) {\n      // on \"oneOnOne\" we consider the start widget as the convergent one\n      const convergesOnEnd = arrow.chartBranch.type === \"manyToOne\"; \n      let convergencePoint = convergesOnEnd ? arrow.points[1] : arrow.points[0];\n      let nonConvergencePoint = convergesOnEnd ? arrow.points[0] : arrow.points[1];\n      const convergentWidget = convergesOnEnd ? endWidget : startWidget;\n      const nonConvergentWidget = convergesOnEnd ? startWidget : endWidget;\n      \n      convergencePoint = this.getWidgetSideMidPosition(convergencePoint, convergentWidget);\n      nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n    \n      if(toOrientation(arrow.chartBranch.convergenceSide) === \"horizontal\") {\n        // if inside, use 2-segment arrow\n        if(arrow.chartBranch.position >= nonConvergentWidget.x && arrow.chartBranch.position <= nonConvergentWidget.x + nonConvergentWidget.width) {\n          nonConvergencePoint.x = arrow.chartBranch.position;\n          nonConvergencePoint.y = (nonConvergentWidget.y + nonConvergentWidget.height/2) > convergencePoint.y ? nonConvergentWidget.y : nonConvergentWidget.y + nonConvergentWidget.height;\n        // otherwise use regular 3-segment arrow but make sure it connects to the correct side\n        } else {\n          nonConvergencePoint.type = arrow.chartBranch.position < nonConvergentWidget.x ? \"left\" : \"right\";\n          nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n        }\n      } else {  // vertical\n        // if inside, use 2-segment arrow\n        if(arrow.chartBranch.position >= nonConvergentWidget.y && arrow.chartBranch.position <= nonConvergentWidget.y + nonConvergentWidget.height) {\n          nonConvergencePoint.x = (nonConvergentWidget.x + nonConvergentWidget.width/2) > convergencePoint.x ? nonConvergentWidget.x : nonConvergentWidget.x + nonConvergentWidget.width;\n          nonConvergencePoint.y = arrow.chartBranch.position;\n        // otherwise use regular 3-segment arrow but make sure it connects to the correct side\n        } else {\n          nonConvergencePoint.type = arrow.chartBranch.position < nonConvergentWidget.y ? \"top\" : \"bottom\";\n          nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n        }\n      }\n\n      arrow.points[0] = convergesOnEnd ? nonConvergencePoint : convergencePoint;\n      arrow.points[1] = convergesOnEnd ? convergencePoint : nonConvergencePoint;\n    }\n  }\n  \n  isChartSideArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    // can't be chartSide if there is any chartBranch on current side\n    if(this.getSharedChartBranchArrow(arrow, widgets)) return;\n\n    return ((arrow.initialIsHorizontal && (arrow.points[0].type === \"top\" || arrow.points[0].type === \"bottom\")) ||\n    (!arrow.initialIsHorizontal && (arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\")));\n  }\n\n  // returns true if using intersection chartSide\n  updateArrowChartSide(arrow: ArrowWidget, startWidget: Widget, endWidget: Widget) {\n    // if widgets limits are intersecting, use chartSide connector\n    if(arrow.initialIsHorizontal) {\n      const middleX = this.getIntersectionMiddle(startWidget.x, startWidget.width, endWidget.x, endWidget.width);\n      if(middleX) {\n        arrow.points[0].x = middleX;\n        arrow.points[1].x = middleX;\n        return true;\n      }\n    } else {\n      const middleY = this.getIntersectionMiddle(startWidget.y, startWidget.height, endWidget.y, endWidget.height);\n      if(middleY) {\n        arrow.points[0].y = middleY;\n        arrow.points[1].y = middleY;\n        return true;\n      }\n    }\n\n    // if there is no intersection, use original axis side\n    if(arrow.initialIsHorizontal) {\n      arrow.points[0].type = endWidget.x > startWidget.x + (startWidget.width / 2) ? \"right\" : \"left\";\n    } else {\n      arrow.points[0].type = endWidget.y > startWidget.y + (startWidget.height / 2) ? \"bottom\" : \"top\";\n    }\n    arrow.points[0] = this.getWidgetSideMidPosition(arrow.points[0], startWidget);\n    \n    const startWidgetCenter = {x: startWidget.x + (startWidget.width/2), y: startWidget.y + (startWidget.height/2)};\n    const endWidgetCenter = {x: endWidget.x + (endWidget.width/2), y: endWidget.y + (endWidget.height/2)};\n    const distX = Math.abs(startWidgetCenter.x - endWidgetCenter.x) - (startWidget.width/2 + endWidget.width/2);\n    const distY = Math.abs(startWidgetCenter.y - endWidgetCenter.y) - (startWidget.height/2 + endWidget.height/2);\n    const widgetsTooClose = arrow.initialIsHorizontal ? distX <= ARROW_MARGIN : distY <= ARROW_MARGIN;\n    \n    // if widgets are too close, use 2-segments arrow\n    if(widgetsTooClose) {\n      // never closer than 20px from origin and never less than 10px from target side\n      if(arrow.initialIsHorizontal) {\n        arrow.points[1].type = endWidget.y > arrow.points[0].y ? \"top\" : \"bottom\";\n        let distXToCenter = startWidget.width/2 + Math.max(distX + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n        arrow.points[1].x = startWidgetCenter.x + (arrow.points[0].type === \"right\" ? distXToCenter : -distXToCenter);\n        arrow.points[1].y = arrow.points[1].type === \"top\" ? endWidget.y : endWidget.y + endWidget.height;\n      } else {\n        arrow.points[1].type = endWidget.x > arrow.points[0].x ? \"left\" : \"right\";\n        let distYToCenter = startWidget.height/2 + Math.max(distY + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n        arrow.points[1].x = arrow.points[1].type === \"left\" ? endWidget.x : endWidget.x + endWidget.width;\n        arrow.points[1].y = startWidgetCenter.y + (arrow.points[0].type === \"bottom\" ? distYToCenter : -distYToCenter);\n      }\n    // otherwise use regular 3-segments arrow\n    } else {\n      if(arrow.initialIsHorizontal) {\n        \tarrow.points[1].type = arrow.points[0].type === \"right\" ? \"left\" : \"right\";\n      } else {\n        arrow.points[1].type = arrow.points[0].type === \"bottom\" ? \"top\" : \"bottom\";\n      }\n      arrow.points[1] = this.getWidgetSideMidPosition(arrow.points[1], endWidget);\n    }\n\n    return false;\n  }\n\n  // returns if any widgets are at \"distance\" or lower in the requested axis\n  widgetsTooClose(a: Widget, b: Widget, distance: number, horizontal: boolean) {\n    const aCenter = {x: a.x + (a.width/2), y: a.y + (a.height/2)};\n    const bCenter = {x: b.x + (b.width/2), y: b.y + (b.height/2)};\n    if(horizontal) {\n      const distX = Math.abs(aCenter.x - bCenter.x) - (a.width/2 + b.width/2);\n      return distX <= distance;\n    }\n    const distY = Math.abs(aCenter.y - bCenter.y) - (a.height/2 + b.height/2);\n    return distY <= distance;\n  }\n\n  // returns the middle point of an intersection\n  getIntersectionMiddle(min1: number, size1: number, min2: number, size2: number) {\n    const max1 = min1 + size1;\n    const max2 = min2 + size2;\n\n    // TODO: none of this works when moving endWidget\n    // TODO: make sure this works with different shaped widgets\n    // if((this.between(min1, min2, max2) && this.between(max1, min2, max2)) ||\n    //    (this.between(min2, min1, max1) && this.between(max2, min1, max1))) {\n    if((min1 === min2 && max1 === max2) ||\n      (min1 > min2 && min1 < max2)) {\n      const intersection = max2 - min1;\n      if(intersection <= ARROW_MARGIN * 2) return null;\n      \n      return min1 + (intersection / 2);\n    } else if(max1 > min2 && max1 < max2) {\n      const intersection = max1 - min2;\n      if(intersection <= ARROW_MARGIN * 2) return null;\n\n      return max1 - (intersection / 2);\n    }\n\n    // no intersection\n    return null;\n  }\n\n  between(value: number, min: number, max: number) {\n    return value>min && value<max;\n  }\n  \n  getWidgetSideMidPosition(point: Point, widget: Widget) {\n    let newPoint: Point = {type: point.type, x: 0, y: 0};\n    switch(point.type) {\n      case \"top\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y;\n        break;\n      case \"right\":\n        newPoint.x = widget.x + widget.width;\n        newPoint.y = widget.y + widget.height / 2;\n        break;\n      case \"bottom\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y + widget.height;\n        break;\n      case \"left\":\n        newPoint.x = widget.x;\n        newPoint.y = widget.y + widget.height / 2;\n        break;\n    }\n\n    return newPoint;\n  }\n\n  render() {\n    const { cursor, selected, widgets } = this.state;\n    return (\n      <div>\n        <div\n          id=\"canvas\"\n          style={{ cursor }}\n          className=\"App\"\n          tabIndex={1}\n          onClick={this.handleClick}\n          onDoubleClick={this.handleDoubleClick}\n          onKeyDown={this.handleKeyDown}\n          onMouseMove={this.handleDrag}\n          onMouseDown={this.handleMouseDown}\n          onMouseUp={this.handleMouseUp}\n          ref={this.handleRef}\n          >\n          {Object.values(widgets).map((w) => {\n            if (w.type === \"sticky\") {\n              return (\n                <Sticky\n                cursor={cursor}\n                onClick={this.handleStickyClick}\n                onDragStart={this.handleWidgetDragStart}\n                onMouseHover={this.handleMouseHoverSticky}\n                onMouseLeave={this.handleMouseLeaveSticky}\n                selected={selected === w.id}\n                widget={w}\n                key={w.id}\n                />\n                );\n            }\n            \n            if (w.type === \"arrow\") {\n              return <Arrow widget={w} key={w.id} />;\n            }\n            \n            return null;\n          })}\n        </div>\n        <div id=\"settings\" style={settingsStyle}>\n          <Checkbox\n            label=\"Stick To Convergent Widget Side\"\n            onCheckedChange={(checked) => this.setState({settings: { stickToConvergentWidgetSide: checked }})} />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}