{"version":3,"sources":["widgets/Sticky.tsx","widgets/Arrow.tsx","settings/Checkbox.tsx","types.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleDragStart","e","props","onDragStart","widget","cursor","onMouseDown","id","handleMouseUp","onMouseUp","handleMouseHover","onMouseHover","handleMouseLeave","onMouseLeave","this","selected","x","y","width","height","onMouseMove","style","top","left","border","className","SNAPPING_POINT_WIDTH","React","Component","Arrow","state","draggingSegment","draggingSegmentNumber","editing","label","segment","text","pos","ref","getPoints","points","start","end","length","handleSegmentDragStart","index","onDragSegmentStart","clientX","clientY","normalizedIndex","setState","handleSegmentDragEnd","console","log","position","onDragSegmentEnd","undefined","handleMouseMove","type","onDragSegment","connectionDot","key","direction","handleDragPointStart","onDragPointStart","stroke","fill","d","fillRule","transform","getRotation","transformOrigin","cx","cy","r","strokeWidth","dir","pathGenerator","showLabels","isHorizontalStart","arrowPath","forEach","point","next","push","pointerEvents","onDoubleClick","handleDoubleClick","paths","createLabel","withConnectionDot","labelSize","nextPoint","center","tabIndex","onClick","handleTextClick","handleRef","window","editingLabel","document","addEventListener","handleDocClick","b","getBoundingClientRect","okH","okV","textContent","removeEventListener","stopPropagation","target","pathID","Number","replace","path","contentEditable","suppressContentEditableWarning","xmlns","version","PureComponent","Checkbox","checked","handleOnChange","prevState","onCheckedChange","onChange","defaultChecked","stickyFactory","spec","uuid","arrowFactory","arrowType","chartBranch","initialIsHorizontal","toOrientation","arrowIsHorizontal","arrow","settingsStyle","borderStyle","backgroundColor","padding","App","settings","stickToConvergentWidgetSide","initialId","endId","widgets","newSegment","mousePosition","mouseOverSticky","handleArrowPointDragStart","isStart","startPoint","initial","endPoint","handleStickyMouseDown","handleStickyMouseUp","draggingArrow","startWidget","endWidget","setArrowChartBranch","cancelArrowCreation","stickyWidth","ctrlKey","metaKey","s","handleDrag","deltaX","deltaY","draggingWidgets","map","arrows","Object","values","filter","w","connectedArrows","includes","reduce","acc","cur","updateArrow","a","movedWidgets","handleMouseHoverSticky","targetChanged","newWidgets","opositePoint","handleMouseLeaveSticky","handleWidgetDragStart","shiftKey","button","handleKeyDown","newCursor","selectedWidgetsId","prevWidgets","handleMouseDown","isDraggingArrow","getConnectedStickyPos","coords","STICKY_HEIGHT","draggingPoint","isChartSideArrow","updateArrowChartSide","focus","getStartPointType","first","second","getEndPointType","reverse","handleDragSementStart","arrowId","horizontalDrag","isFirst","isLast","last","third","unalteredEndPoints","slice","unalteredPoints","handleDragSegment","handleDragSegmentEnd","splice","startType","endType","setIntermidiatePoints","p2","p3","p4","isHorizontalEnd","midDistance","middlePoint","segment2Position","convergenceTarget","convergenceSide","handleCheckStick","handleCheckLabels","draggingWidget","chartBranchArrow","getSharedChartBranchArrow","assign","chartBranchArrows","draggingPosition","isDisconnectedArrow","connectedWidget","draggingX","draggingY","draggingWidth","draggingHeight","getWidgetSideMidPosition","convergesOnEnd","convergencePoint","nonConvergencePoint","convergentWidget","nonConvergentWidget","middleX","getIntersectionMiddle","middleY","startWidgetCenter","endWidgetCenter","distX","Math","abs","distY","distXToCenter","max","distYToCenter","min1","size1","min2","size2","max1","max2","intersection","ARROW_MARGIN","value","min","newPoint","onKeyDown","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.9e3fb0d5.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\nconst SNAPPING_POINT_WIDTH = 30;\nconst SNAPPING_POINT_CENTER = SNAPPING_POINT_WIDTH / 2;\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onMouseDown: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onMouseUp: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDragStart: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onMouseHover: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onMouseLeave: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  selected: boolean;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.Component<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onDragStart, widget, cursor, onMouseDown } = this.props;\n    if (cursor === 'crosshair') onMouseDown(widget.id, e);\n    else onDragStart(widget.id, e);\n  };\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onMouseUp, cursor, widget } = this.props;\n    if (cursor === 'crosshair') onMouseUp(widget.id, e);\n  };\n  \n  handleMouseHover = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onMouseHover, widget } = this.props;\n    onMouseHover(widget.id, e);\n  };\n\n  handleMouseLeave = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onMouseLeave, widget } = this.props;\n    onMouseLeave(widget.id, e);\n  };\n\n  render() {\n    const {\n      cursor,\n      selected,\n      widget: { x, y , width, height},\n    } = this.props;\n    return (\n      <div\n        onMouseUp={this.handleMouseUp}\n        onMouseDown={this.handleDragStart}\n        onMouseMove={this.handleMouseHover}\n        onMouseLeave={this.handleMouseLeave}\n        style={{\n          top: y,\n          left: x,\n          width: width,\n          height: height,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n          border: selected ? \"2px solid blue\" : \"none\",\n        }}\n        className=\"Sticky\"\n        >\n        <div\n          className=\"snapping-point top\"\n          style={{\n            top: 0 - SNAPPING_POINT_CENTER,\n            left: (width / 2) - SNAPPING_POINT_CENTER,\n            width: SNAPPING_POINT_WIDTH,\n            height: SNAPPING_POINT_WIDTH,\n          }}\n          id=\"top\"\n        ></div>\n        <div\n          className=\"snapping-point right\"\n          style={{\n            top: (height / 2) - SNAPPING_POINT_CENTER,\n            left: width - SNAPPING_POINT_CENTER,\n            width: SNAPPING_POINT_WIDTH,\n            height: SNAPPING_POINT_WIDTH,\n          }}\n          id=\"right\"\n        ></div>\n        <div\n          className=\"snapping-point bottom\"\n          style={{\n            top: height - SNAPPING_POINT_CENTER,\n            left: (width / 2) - SNAPPING_POINT_CENTER,\n            width: SNAPPING_POINT_WIDTH,\n            height: SNAPPING_POINT_WIDTH,\n          }}\n          id=\"bottom\"\n        ></div>\n        <div\n          className=\"snapping-point left\"\n          style={{\n            top: (height / 2) - SNAPPING_POINT_CENTER,\n            left: 0 - SNAPPING_POINT_CENTER,\n            width: SNAPPING_POINT_WIDTH,\n            height: SNAPPING_POINT_WIDTH,\n          }}\n          id=\"left\"\n        ></div>\n        {/* <svg className=\"auto-affordance\">\n        <circle\n          cx={`${width / 2}`}\n          cy={`${height / 2}`}\n          r=\"5\"\n          stroke={'#1c7ff9'}\n          fill='none'\n          ></circle>\n          </svg> */}\n      </div>\n    );\n  }\n}\n\nexport default Sticky;\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport \"./Arrow.css\";\nimport { ArrowWidget, Point, PointType, Position } from \"../types\";\n\ntype Direction = 'horizontal' | 'vertical' | 'other';\n\ndeclare const window: any;\n\ninterface PropTypes {\n  widget: ArrowWidget;\n  onDragPointStart: (id: string, e: React.MouseEvent, isStart: boolean) => void;\n  onDragSegmentEnd: (id: string, index: number, position?: number) => void;\n  onDragSegment: (id: string, index: number, position: Position) => void;\n  onDragSegmentStart: (id: string, index: number, position: Position) => void;\n  showLabels: boolean;\n}\n\ninterface State {\n  draggingSegment: boolean;\n  draggingSegmentNumber: number; // indicates which segment is being dragged\n  position?: number;\n  editing: boolean;\n  label: {\n    segment: number;\n    text: string;\n    pos: number;\n  };\n}\n\nclass Arrow extends React.PureComponent<PropTypes, State> {\n  state: State = {\n    draggingSegment: false,\n    draggingSegmentNumber: -1,\n    editing: false,\n    label: {\n      segment: -1,\n      text: 'label',\n      pos: -1,\n    },\n  };\n  ref: SVGTextElement | null = null;\n\n  getPoints = () => {\n    const { points } = this.props.widget;\n    const start = points[0];\n    const end = points[points.length - 1];\n\n    return { start, end }\n  }\n\n  handleSegmentDragStart = (e: React.MouseEvent, index: number) => {\n    if (this.state.draggingSegment) return;\n    this.props.onDragSegmentStart(this.props.widget.id, index, { x: e.clientX, y: e.clientY })\n    const normalizedIndex = index === 0\n      ? 1\n      : index;\n    this.setState({ draggingSegment: true, draggingSegmentNumber: normalizedIndex })\n  }\n\n  handleSegmentDragEnd = () => {\n    console.log('handleSegmentDragEnd');\n    if (!this.state.draggingSegment) return;\n    // Create chart branch after dragging middle segment\n    const pos = this.state.position;\n    this.props.onDragSegmentEnd(this.props.widget.id, this.state.draggingSegmentNumber, pos);\n    this.setState({ draggingSegment: false, draggingSegmentNumber: -1, position: undefined })\n  }\n\n  handleMouseMove = ({ clientX, clientY }: React.MouseEvent<SVGSVGElement, MouseEvent>) => {\n    const { draggingSegmentNumber } = this.state;\n    if(!this.state.draggingSegment) return;\n\n    const { start } = this.getPoints();\n    \n    if ((start.type === 'right' || start.type === 'left') && draggingSegmentNumber % 2 !== 0 ) {\n      this.setState({ position: clientX });\n    } else {\n      this.setState({ position: clientY });\n    }\n    this.props.onDragSegment(this.props.widget.id, draggingSegmentNumber, { x: clientX, y: clientY });\n  }\n\n  connectionDot = (x: number, y: number, key: string, direction?: PointType) => {\n    const handleDragPointStart = (e: React.MouseEvent) => {\n      const { onDragPointStart, widget } = this.props;\n      onDragPointStart(widget.id, e, !direction);\n    }\n    if (!direction) {\n      return <circle\n        key={key}\n        cx={`${x}`}\n        cy={`${y}`}\n        r=\"2\"\n        stroke='transparent'\n        fill='black'\n        strokeWidth=\"6\"\n        onMouseDown={handleDragPointStart}\n        ></circle>\n    } else {\n      return <path\n        key={key}\n        className='connectionDot'\n        stroke=\"#000\"\n        fill=\"#000\"\n        d={`M${x} ${y} L${x - 8} ${y + 3}V${y - 3}z`}\n        fillRule=\"evenodd\"\n        style={{ transform: `rotate(${this.getRotation(direction)}deg)`, transformOrigin: `${x}px ${y}px` }}\n        onMouseDown={handleDragPointStart}\n      />;\n    }\n  };\n  getRotation = (dir: PointType) => {\n    switch (dir) {\n      case 'right': return 180;\n      case 'left': return 0;\n      case 'top': return 90;\n      case 'bottom': return -90;\n    }\n  }\n\n  pathGenerator = () => {\n    const { points } = this.props.widget;\n    const { showLabels } = this.props;\n    if (points.length < 2) return null;\n\n    const start = points[0];\n    const end = points[points.length - 1];\n    const withConnectionDot = (arrowPath: JSX.Element[]) => [\n      this.connectionDot(start.x, start.y, '0'),\n      ...arrowPath,\n      this.connectionDot(end.x, end.y, '100', end.type),\n    ];\n    const isHorizontalStart = start.type === \"right\" || start.type === \"left\";\n    const cursor = (index: number) => (isHorizontalStart && index % 2 !== 0) || (!isHorizontalStart && index % 2 === 0) ? 'ew-resize' : 'ns-resize'\n    const arrowPath: JSX.Element[] = [];\n    points.forEach((point, index) => {\n      const onDragStart = (e: React.MouseEvent) => this.handleSegmentDragStart(e, index);\n      const next = points[index + 1];\n      if (!next) return;\n      arrowPath.push(<path\n        key={index + 1} // 0 is the first circle\n        id={`path-${index}`}\n        d={`M ${point.x} ${point.y} L ${next.x} ${next.y}`}\n        stroke=\"black\"\n        strokeWidth=\"2\"\n        fill=\"none\"\n        style={{\n          cursor: cursor(index),\n          pointerEvents: 'auto'\n        }}\n        onMouseDown={onDragStart}\n        onDoubleClick={this.handleDoubleClick}\n      />)\n    });\n\n    const paths = arrowPath;\n    if (showLabels) {\n      const label = this.createLabel(points);\n      if (label) paths.push(label);\n    }\n    return withConnectionDot(paths);\n  };\n\n  createLabel = (points: Point[]) => {\n    const { label } = this.state;\n    if (label.segment === -1) return null;\n\n    // super hacky sizing method\n    const labelSize = { width: 8 * label.text.length, height: 18 };\n    const point = points[label.segment];\n    const nextPoint = points[label.segment + 1];\n    const center = {\n      x: point.x + (nextPoint.x - point.x) / 2 - labelSize.width / 2,\n      y: (point.y + (nextPoint.y - point.y) / 2) + labelSize.height / 3,\n    };\n    /*\n    const middlePointIndex = Math.floor(points.length / 2);\n    const middlePoint = points[middlePointIndex - 1];\n    const nextMiddlePoint = points[middlePointIndex];\n    const center = {\n      x:\n        middlePoint.x +\n        (nextMiddlePoint.x - middlePoint.x) / 2 -\n        labelSize.width / 2,\n      y:\n        middlePoint.y +\n        (nextMiddlePoint.y - middlePoint.y) / 2 +\n        labelSize.height / 4,\n    };\n    */\n    return (\n      <text\n        key=\"label\"\n        transform={`matrix(1 0 0 1 ${center.x} ${center.y})`}\n        style={{\n          cursor: this.state.editing ? 'auto' : 'pointer',\n          pointerEvents: 'auto'\n        }}\n        tabIndex={0}\n        onClick={this.handleTextClick}\n        ref={this.handleRef}\n      >\n        {label.text}\n      </text>\n    );\n  };\n\n  handleRef = (ref: SVGTextElement) => {\n    this.ref = ref;\n  }\n\n  handleTextClick = () => {\n    if (this.state.editing) return;\n\n    // hacky hack to prevent 'c' shortcut to screw up typing\n    window.editingLabel = true;\n    this.setState({ editing: true });\n    document.addEventListener('click', this.handleDocClick);\n  };\n\n  handleDocClick  = (e: any) => {\n    if (!this.ref) return;\n    const b = this.ref.getBoundingClientRect();\n    const okH = e.clientX > b.left && e.clientX < b.left + b.width;\n    const okV = e.clientY > b.top && e.clientY < b.top + b.height;\n    const inside = okH && okV;\n    if (!inside) {\n      window.editingLabel = false;\n      this.setState({\n        editing: false,\n        label: {\n          segment: -1,\n          text: this.ref.textContent || '',\n          pos: -1,\n        },\n      });\n      document.removeEventListener('click', this.handleDocClick);\n    }\n  };\n\n  handleDoubleClick = (e: any) => {\n    e.stopPropagation();\n    console.log(e.target.id);\n    const pathID = Number(e.target.id.replace('path-', ''));\n    console.log('handleDoubleClick', pathID)\n    this.setState({ label: { ...this.state.label, segment: pathID }, })\n  };\n\n  render() {\n    const path = this.pathGenerator();\n    if (!path) return null;\n    const { editing, draggingSegment } = this.state;\n\n    return (\n      <div\n        contentEditable={editing}\n        suppressContentEditableWarning\n      >\n        <svg\n          style={{\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            pointerEvents: draggingSegment ? \"auto\" : \"none\",\n          }}\n          xmlns=\"http://www.w3.org/2000/svg\"\n          version=\"1.1\"\n          className=\"Arrow\"\n          onMouseUp={this.handleSegmentDragEnd}\n          onMouseMove={this.handleMouseMove}\n        >\n          { path }\n        </svg>\n      </div>\n    );\n  }\n}\n\nexport default Arrow;\n","import React from \"react\";\r\n\r\ninterface PropTypes {\r\n  label: string;\r\n  onCheckedChange: (checked: boolean) => void;\r\n}\r\n\r\ninterface State {\r\n  checked: boolean;\r\n}\r\n\r\nclass Checkbox extends React.PureComponent<PropTypes, State> {\r\n  state: State = {\r\n    checked: false,\r\n  };\r\n\r\n  handleOnChange = (e: React.ChangeEvent<HTMLInputElement>) => { \r\n    this.setState((prevState) => {\r\n      const checked = !prevState.checked;\r\n      this.props.onCheckedChange(checked);\r\n      return {\r\n        checked\r\n      };\r\n    });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div style={{height: \"auto\"}}>\r\n        <label>\r\n          <input\r\n            type=\"checkbox\"\r\n            style={{width: 15, height: 15}}\r\n            onChange={this.handleOnChange}\r\n            defaultChecked={this.state.checked} />\r\n          {this.props.label}\r\n        </label>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Checkbox;","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\nexport type Orientation = \"horizontal\" | \"vertical\";\nexport type ChartBranchType = \"oneToOne\" | \"oneToMany\" | \"manyToOne\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type?: PointType; // only first and last points have type\n}\n\nexport interface Position {\n  x: number;\n  y: number;\n}\n\nexport interface ChartBranch {\n  position: number; // fixed position where arrows share the 2nd branch segment\n  convergenceSide?: PointType;  // side of the widget where the arrows converge (might be start or end widget depending of ChartBranchType)\n  type: ChartBranchType;\n}\n\n// initial: initial simple arrow, centered to the connected widgets on both ends, bent into 3 segments having the same length in both parallel segments.\n// chartBranch: created from an 'initial' arrow, centered to the connected widgets on both ends, bent into 3 segments, can share inital segment with other 'chartBranch' arrows, 1st segment size stays put.\n// chartSide: created from an 'initial' arrow, moved to the side of a group of 'chartBranch' arrows and can be on any point of both connected widgets.\nexport type ArrowType = \"initial\" | \"chartBranch\" | \"chartSide\";\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  startPoint?: PointType | null; // when start point is manually set\n  endPoint?: PointType | null; // when end point is manually set\n  end: string | null;\n  arrowType: ArrowType;\n  chartBranch: ChartBranch | null;\n  initialIsHorizontal: boolean;\n  showLabels: boolean;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: spec.height ?? 100,\n  width: spec.width ?? 100,\n  type: \"sticky\",\n  x: spec.x || 0,\n  y: spec.y || 0,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n  arrowType: spec.arrowType || \"initial\",\n  chartBranch: null,\n  initialIsHorizontal: spec.initialIsHorizontal || true,\n  showLabels: spec.showLabels || false,\n});\n\nexport const toOrientation = (type: PointType) : Orientation => {\n  return type === \"left\" || type === \"right\" ? \"horizontal\" : \"vertical\";\n}\n","import React, { CSSProperties } from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport Arrow from \"./widgets/Arrow\";\nimport Checkbox from \"./settings/Checkbox\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n  Position,\n  toOrientation,\n  ChartBranch,\n  PointType,\n} from \"./types\";\n\nexport const SNAPPING_DISTANCE = 10;\nexport const TOLERANCE = 10;\nexport const ARROW_MARGIN = 10;\nexport const TWO_SEGMENT_ARROW_MIN = 20;\nexport const STICKY_HEIGHT = 100;\n\nconst arrowIsHorizontal = (arrow: ArrowWidget) =>\n  arrow.points[0].type === 'left' || arrow.points[0].type === 'right';\n\nexport const settingsStyle: React.CSSProperties = {\n  position: \"absolute\",\n  top: 0,\n  width:\"auto\",\n  height: \"auto\",\n  borderStyle: \"solid\",\n  backgroundColor: \"lightgray\",\n  padding: 10,\n};\n\ndeclare const window: any;\n\ninterface State {\n  settings:{\n    stickToConvergentWidgetSide: boolean;\n    showLabels: boolean;\n  };\n  cursor: React.CSSProperties[\"cursor\"];\n  dragging: string[] | null;\n  initialId: string | null;\n  endId: string | null;\n  selected: string[] | null;\n  widgets: Record<string, Widget>;\n  newSegment: boolean;\n}\n\nclass App extends React.Component<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    settings :{\n      stickToConvergentWidgetSide: false,\n      showLabels: false,\n    },\n    cursor: \"auto\",\n    dragging: null,\n    initialId: null,\n    endId: null,\n    selected: null,\n    widgets: {},\n    newSegment: false,\n  };\n  mousePosition: Position | null = null;\n  mouseOverSticky: boolean = false;\n\n  cancelArrowCreation() {\n    this.setState((prevState) => {\n      if(prevState.dragging && prevState.dragging.length) {\n        // delete dragging arrow if any\n        const draggingWidget = { ...prevState.widgets[prevState.dragging[0]] };\n        if(draggingWidget.type === \"arrow\") {\n          const prevWidgets = prevState.widgets;\n          delete prevWidgets[draggingWidget.id];\n          return {\n            ...prevState,\n            dragging: null,\n            initialId: null,\n            endId: null,\n            cursor: \"auto\",\n            widgets: { ...prevWidgets },\n          }\n        }\n      }\n\n      return {\n        ...prevState,\n        dragging: null,\n        initialId: null,\n        endId: null,\n        cursor: \"auto\",\n      }\n    });\n  }\n\n  handleArrowPointDragStart = (id: string, e: React.MouseEvent, isStart: boolean) => {\n    if (isStart) {\n      const end = (this.state.widgets[id] as ArrowWidget).end;\n      this.setState((prevState) => (\n        {\n          ...prevState,\n          cursor: 'crosshair',\n          dragging: [id],\n          endId: end,\n          initialId: null,\n          widgets: {\n            ...prevState.widgets,\n            [id]: {\n              ...prevState.widgets[id],\n              start: null,\n              startPoint: null,\n              initialIsHorizontal: arrowIsHorizontal(prevState.widgets[id] as ArrowWidget),\n            }\n          }\n        }\n      ));\n    } else {\n      const initial = (this.state.widgets[id] as ArrowWidget).start;\n      this.setState((prevState) => (\n        {\n          ...prevState,\n          cursor: 'crosshair',\n          dragging: [id],\n          initialId: initial,\n          endId: null,\n          widgets: {\n            ...prevState.widgets,\n            [id]: {\n              ...prevState.widgets[id],\n              end: null,\n              endPoint: null,\n              initialIsHorizontal: arrowIsHorizontal(prevState.widgets[id] as ArrowWidget),\n            }\n          }\n        }\n      ));\n    }\n  }\n\n  handleStickyMouseDown = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    if (this.state.cursor !== \"crosshair\")\n      return;\n    // start arrow creation\n    if (!this.state.dragging) {\n      // create Arrow for dragging without end widget\n      this.setState((prevState) => {\n        const arrow = {\n          ...arrowFactory({ start: id, end: null }),\n        };\n\n        return {\n          ...prevState,\n          initialId: id,\n          endId: null,\n          widgets: {\n            ...prevState.widgets,\n            [arrow.id]: arrow,\n          },\n          dragging: [arrow.id],\n        };\n      });\n\n      return;\n    }\n  }\n\n  handleStickyMouseUp = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.stopPropagation(); // avoid executing `handleMouseUp`\n    if (this.state.initialId === id || this.state.endId === id) {\n      this.cancelArrowCreation();\n      return;\n    }\n\n    if (this.state.cursor !== \"crosshair\")\n      return;\n    \n    this.setState((prevState) => {\n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      const draggingArrow = { ...prevState.widgets[prevState.dragging[0]] } as ArrowWidget;\n      const startWidget = prevState.widgets[draggingArrow.start ?? id];\n      const endWidget = prevState.widgets[draggingArrow.end ?? id];\n      \n      // update Arrow start/end and connect it to both widgets\n      draggingArrow.start = startWidget.id;\n      draggingArrow.end = endWidget.id;\n      draggingArrow.initialIsHorizontal = arrowIsHorizontal(draggingArrow);\n      // update chart branches state (for both start and end arrows)\n      this.setArrowChartBranch(draggingArrow as ArrowWidget, this.state.widgets, false);\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        dragging: null,\n        initialId: null,\n        endId: null,\n        widgets: {\n          ...prevState.widgets,\n          [draggingArrow.id]: draggingArrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    // create rectangular stickies while holding CTRL down\n    const stickyWidth = (e.ctrlKey || e.metaKey) ? 150 : 100;\n    const s = stickyFactory({ x: e.clientX - (stickyWidth / 2), y: e.clientY - 50, width: stickyWidth });\n    this.setState((prevState) => ({\n      selected: [s.id],\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (e: React.MouseEvent<HTMLDivElement>) => {\n    const deltaX = this.mousePosition ? e.clientX - this.mousePosition.x : e.clientX;\n    const deltaY = this.mousePosition ? e.clientY - this.mousePosition.y : e.clientY;\n    this.mousePosition = {x: e.clientX, y: e.clientY };\n    const { dragging, widgets } = this.state;\n\n    if (!dragging)\n      return;\n    const draggingWidgets = dragging.map(id => widgets[id]);\n    if(draggingWidgets.length > 1 || draggingWidgets[0].type === \"sticky\") {\n      const arrows = Object.values(widgets).filter(w => w.type === \"arrow\") as ArrowWidget[];\n      // update connected arrows\n      const connectedArrows = Object.values(widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          dragging &&\n          ((w.start && dragging.includes(w.start)) ||\n          (w.end && dragging.includes(w.end))))\n      .reduce((acc, cur) => {\n        const arrow = cur as ArrowWidget;\n        this.updateArrow(arrow);\n        if (dragging &&\n          ((arrow.start && dragging.includes(arrow.start)) &&\n          (arrow.end && dragging.includes(arrow.end))) &&\n          arrow.chartBranch) {\n            if (arrow.chartBranch.type === 'oneToOne') {\n              arrow.chartBranch.position = arrow.chartBranch.position + (arrowIsHorizontal(arrow) ? deltaX : deltaY);\n            } else {\n              arrows.forEach(a => {\n                if (a.chartBranch && a.chartBranch?.position === arrow.chartBranch?.position) {\n                  if ((a.end && !dragging.includes(a.end)) || (a.start && !dragging.includes(a.start))) {\n                    return;\n                  } else {\n                    arrow.chartBranch.position = arrow.chartBranch.position + (arrowIsHorizontal(arrow) ? deltaX : deltaY);\n                  }\n                }\n              })\n            }\n          }\n        \n        return {\n          ...acc,\n          [arrow.id]: {\n            ...arrow,\n          },\n        };\n      }, {} as Record<string, Widget>);\n  \n      const movedWidgets: Record<string, Widget> = draggingWidgets.reduce((acc, cur) => {\n        return {\n          ...acc,\n          [cur.id]: {\n            ...cur,\n            x: cur.x + deltaX,\n            y: cur.y + deltaY,\n          }\n        };\n      }, {});\n      this.setState({\n        widgets: {\n          ...widgets,\n          ...movedWidgets,\n          ...connectedArrows,\n        }\n      });\n    } else if (draggingWidgets[0].type === \"arrow\" && !this.mouseOverSticky) {\n      const draggingArrow = { ...draggingWidgets[0] };\n      // update arrow dragged end\n      if (!draggingArrow.end || !draggingArrow.start)\n        this.updateArrow(draggingArrow, this.mousePosition);\n      \n      this.setState({\n        widgets: {\n          ...widgets,\n          [draggingArrow.id]: draggingArrow,\n        },\n      });\n    }\n  };\n\n  handleMouseHoverSticky = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    this.mouseOverSticky = true;\n    const target = (e.target as Element).id || null;\n    const { dragging, widgets } = this.state;\n    if (!dragging) return;\n    // stick to widget when hovering while dragging\n    const draggingWidgets = dragging.map(id => widgets[id]);\n    if(draggingWidgets.length === 1 &&\n      draggingWidgets[0].type === \"arrow\") {\n        const draggingArrow = { ...draggingWidgets[0] };\n        // update Arrow start/end and connect it to both widgets\n        const isStart = !!this.state.endId;\n        const targetChanged = isStart\n          ? draggingArrow.startPoint !== target && draggingArrow.start === id\n          : draggingArrow.endPoint !== target && draggingArrow.end === id;\n        if ((draggingArrow.start !== id &&\n          draggingArrow.end !== id) || targetChanged)\n          {\n            // connect to widget and update arrow\n            draggingArrow.start = draggingArrow.start ?? id;\n            draggingArrow.end = draggingArrow.end ?? id;\n            if (isStart) {\n              draggingArrow.startPoint = target !== \"auto\" ? target as PointType : null;\n              draggingArrow.arrowType = 'initial';\n              draggingArrow.chartBranch = null;\n            } else {\n              draggingArrow.endPoint = target !== \"auto\" ? target as PointType : null;\n              draggingArrow.arrowType = 'initial';\n              draggingArrow.chartBranch = null;\n            }\n            this.updateArrow(draggingArrow);\n            const newWidgets = { ...widgets, [draggingArrow.id]: draggingArrow };\n            this.setState({\n              widgets: newWidgets,\n            });\n          }\n    };\n  }\n\n  opositePoint = (point: PointType) => {\n    switch (point) {\n      case 'top': return 'bottom';\n      case 'bottom': return 'top';\n      case 'right': return 'left';\n      case 'left': return 'right';\n    }\n  }\n\n  handleMouseLeaveSticky = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    this.mouseOverSticky = false;\n    const { dragging, widgets } = this.state;\n    if (!dragging) return;\n    const draggingWidgets = dragging.map(id => widgets[id]);\n    if (draggingWidgets.length === 1 &&\n      draggingWidgets[0].type === \"arrow\" &&\n      draggingWidgets[0].start && draggingWidgets[0].end &&\n      (draggingWidgets[0].start === id ||\n      draggingWidgets[0].end === id)) {\n      // disconnect from widget and update arrow\n      const draggingArrow = { ...draggingWidgets[0] };\n      draggingArrow.startPoint = draggingArrow.start === id ? null : draggingArrow.startPoint;\n      draggingArrow.endPoint = draggingArrow.end === id ? null : draggingArrow.endPoint;\n      draggingArrow.start = draggingArrow.start === id ? null : draggingArrow.start;\n      draggingArrow.end = draggingArrow.end === id ? null : draggingArrow.end;\n      \n      this.setState({\n        widgets: {\n          ...widgets,\n          [draggingArrow.id]: draggingArrow,\n        },\n      });\n    }\n    if (draggingWidgets.length === 1 && draggingWidgets[0].type === \"arrow\" && ((draggingWidgets[0].start === id && !draggingWidgets[0].end) || (draggingWidgets[0].end === id && !draggingWidgets[0].start))) {\n      const draggingArrow = { ...draggingWidgets[0] };\n      const widget = this.state.widgets[id];\n      const x = e.clientX;\n      const y = e.clientY;\n      const isHorizontalStart = y > widget.y && y < widget.y + widget.height;\n      const startPoint = isHorizontalStart\n        ? x <= widget.x\n          ? 'left'\n          : 'right'\n        : y <= widget.y\n          ? 'top'\n          : 'bottom';\n      const endPoint = this.opositePoint(startPoint);\n\n      // set initial points\n      this.setState({\n        widgets: {\n          ...widgets,\n          [draggingArrow.id]: {\n            ...draggingArrow,\n            points: [{ x, y, type: startPoint }, { x, y, type: endPoint }],\n            initialIsHorizontal: isHorizontalStart,\n          },\n        },\n      });\n    }\n  }\n\n  handleWidgetDragStart = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const { shiftKey } = e;\n    e.stopPropagation();\n\n    if (e.button !== 0)\n      return;\n\n    if(this.state.dragging)\n      return;\n\n    const selected = (this.state.selected && (this.state.selected.includes(id) || shiftKey))\n    ? !this.state.selected.includes(id)\n      ? [...this.state.selected, id]\n      : this.state.selected\n    : [id];\n    const dragging = (this.state.selected && this.state.selected.includes(id)) ? this.state.selected : [id];\n\n    this.setState({\n      dragging,\n      selected,\n    });\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if((e.key === \"c\" || e.key === \"C\") && !window.editingLabel) {\n      const newCursor = this.state.cursor === \"auto\" ? \"crosshair\" : \"auto\";\n      if(newCursor === \"auto\") {\n        this.cancelArrowCreation();\n      } else {\n        this.setState({\n          cursor: newCursor,\n        });\n      }\n    }\n\n    if ((e.key === \"Backspace\" || e.key === \"Delete\") && !!this.state.selected) {\n      this.setState((prevState) => {\n        const selectedWidgetsId = prevState.selected || null;\n        const prevWidgets = prevState.widgets;\n        selectedWidgetsId?.forEach(id => {\n          Object.values(prevWidgets).forEach((w) => {\n            if (w.type === \"arrow\" && (w.start === id || w.end === id))\n              delete prevWidgets[w.id];\n          });\n          delete prevWidgets[id]\n        });\n\n        return {\n          ...prevState,\n          selected: null,\n          widgets: { ...prevWidgets },\n        };\n      });\n    }\n  };\n\n  handleMouseDown = () => {\n    this.setState({ selected: null });\n  };\n\n  // true when creating an arrow, or when dragging arrow point\n  isDraggingArrow = () => {\n    const draggingWidgets = this.state.dragging && this.state.dragging.map(id => this.state.widgets[id]);\n    return draggingWidgets && draggingWidgets.length === 1 && draggingWidgets[0].type === \"arrow\";\n  }\n\n  getConnectedStickyPos = (point: Point, stickyWidth: number) => {\n    let coords = { x: 0, y: 0 };\n    switch(point.type) {\n      case \"top\":\n        coords.x = point.x - stickyWidth / 2;\n        coords.y = point.y;\n        break;\n      case \"right\":\n        coords.x = point.x - stickyWidth;\n        coords.y = point.y - STICKY_HEIGHT / 2;\n        break;\n      case \"bottom\":\n        coords.x = point.x - stickyWidth / 2;\n        coords.y = point.y - STICKY_HEIGHT;\n        break;\n      case \"left\":\n        coords.x = point.x;\n        coords.y = point.y - stickyWidth / 2;\n        break;\n    }\n\n    return coords;\n  }\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    if(this.isDraggingArrow()) {\n      if (this.state.initialId || this.state.endId) {\n        if (this.state.endId) {\n          this.cancelArrowCreation();\n          return;\n        }\n        // sticky auto-creation after dropping an arrow in the canvas\n        const stickyWidth = (e.ctrlKey || e.metaKey) ? 150 : 100;\n        const draggingWidgets = this.state.dragging && this.state.dragging.map(id => this.state.widgets[id]);\n        const draggingArrow = draggingWidgets && { ...draggingWidgets[0] as ArrowWidget };\n        const draggingPoint = draggingArrow && draggingArrow.points[draggingArrow.points.length - 1];\n        if (!draggingPoint || !draggingArrow) return;\n        const pos = this.getConnectedStickyPos(draggingPoint, stickyWidth);\n        const s = stickyFactory({ ...pos, width: stickyWidth });\n        draggingArrow.end = s.id;\n        draggingArrow.initialIsHorizontal = arrowIsHorizontal(draggingArrow);\n        // update chart branches state (for both start and end arrows)\n        this.setArrowChartBranch(draggingArrow as ArrowWidget, this.state.widgets, false);\n        if (draggingArrow) {\n          this.setState({\n            selected: [s.id],\n            dragging: null,\n            initialId: null,\n            endId: null,\n            cursor: \"auto\",\n            widgets: {\n              ...this.state.widgets,\n              [s.id]: s,\n              [draggingArrow.id]: {\n                ...draggingArrow,\n              }\n            },\n          });\n        }\n      }\n      return;\n    }\n    this.setState((prevState) => {\n      \n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      const connectedArrows = Object.values(prevState.widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          (((w.start && prevState.dragging?.includes(w.start)) || (w.end && prevState.dragging?.includes(w.end))))\n      ).map(w=> w as ArrowWidget)\n      .reduce((acc, arrow) => {\n\n        // stick to your branch side\n        if(!prevState.settings.stickToConvergentWidgetSide || arrow.arrowType !== \"chartBranch\") {\n          if(this.isChartSideArrow(arrow, prevState.widgets)) {\n            const startWidget = prevState.widgets[arrow.start || \"\"] as StickyWidget;\n            const endWidget = prevState.widgets[arrow.end || \"\"] as StickyWidget;\n            if(this.updateArrowChartSide(arrow, startWidget, endWidget)) {\n              arrow.arrowType = \"chartSide\";\n            }\n          }\n          \n          // update chart branches state (for both start and end arrows)\n          this.setArrowChartBranch(arrow, prevState.widgets, false);\n        }\n          \n        // update initial axis\n        arrow.initialIsHorizontal = arrowIsHorizontal(arrow);\n\n        return {\n          ...acc,\n          [arrow.id]: {\n            ...arrow,\n          },\n        };\n      }, {} as Record<string, Widget>);\n      \n      return {\n        dragging: null,\n        widgets: {\n          ...prevState.widgets,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleRef = (ref: HTMLDivElement) => {\n    this.ref = ref;\n    // start focused to listen for key presses\n    if(this.ref) {\n      this.ref.focus();\n    }\n  }\n\n  getStartPointType = (points: Point[]) => {\n    if (points.length < 2) return undefined;\n    const first = points[0];\n    const second = points[1];\n    if (first.x < second.x) return 'right';\n    if (first.x > second.x) return 'left';\n    if (first.y < second.y) return 'bottom';\n    return 'top';\n  }\n\n  getEndPointType = (points: Point[]) => {\n    const reverse = [...points].reverse();\n    return this.getStartPointType(reverse);\n  }\n\n  handleDragSementStart = (arrowId: string, index: number, pos: Position) => {\n    const arrow = this.state.widgets[arrowId] as ArrowWidget;\n    const horizontalDrag = arrowIsHorizontal(arrow)\n      ? index % 2 !== 0\n      : index % 2 === 0;\n    const isFirst = index === 0;\n    const isLast = index === arrow.points.length - 2;\n    // if it's the first or last segment, create a new node\n    if (index === 0 || index === arrow.points.length - 2) {\n\n      if (isFirst && isLast) {\n        const first = arrow.points[0];\n        const last = arrow.points[1];\n        if (horizontalDrag) {\n          const second = { x: pos.x, y: first.y };\n          const third = { x: pos.x, y: last.y };\n          arrow.points = [{ ...first, type: 'right' }, second, third, { ...last, type: 'right' }];\n          // arrow.startPoint = 'right';\n          // arrow.endPoint = 'right';\n        } else {\n          const second = { x: first.x, y: pos.y };\n          const third = { x: last.x, y: pos.y };\n          arrow.points = [{ ...first, type: 'top' }, second, third, { ...last, type: 'top' }];\n          // arrow.startPoint = 'top';\n          // arrow.endPoint = 'top';\n        }\n      } else if (isFirst) {\n        const unalteredEndPoints = arrow.points.slice(2);\n        const first = arrow.points[0];\n        if (horizontalDrag) {\n          const second = { x: pos.x, y: first.y };\n          const third = { x: pos.x, y: arrow.points[1].y };\n          arrow.points = [{ ...first, type: 'right' }, second, third, ...unalteredEndPoints];\n          // arrow.startPoint = 'right';\n        } else {\n          const second = { x: first.x, y: pos.y };\n          const third = { x: arrow.points[1].x, y: pos.y };\n          arrow.points = [{ ...first, type: 'top' }, second, third, ...unalteredEndPoints];\n          // arrow.startPoint = 'top';\n        }\n      } else if (isLast) {\n        const unalteredPoints = arrow.points.slice(0, arrow.points.length - 2);\n        const last = arrow.points[arrow.points.length - 1];\n        if (last.type === 'right' || last.type === 'left') {\n          const second = { x: last.x, y: pos.y };\n          const third = { x: arrow.points[arrow.points.length - 2].x, y: pos.y };\n          arrow.points = [...unalteredPoints, third, second, { ...last, type: 'top' }];\n          // arrow.endPoint = 'top';\n        } else {\n          const second = { x: pos.x, y: last.y };\n          const third = { x: pos.x, y: arrow.points[arrow.points.length - 2].y };\n          arrow.points = [...unalteredPoints, third, second, { ...last, type: 'right' }];\n          // arrow.endPoint = 'right';\n        }\n      }\n      this.setState({ widgets: { ...this.state.widgets, [arrowId]: arrow}, newSegment: isFirst || isLast });\n    }\n  }\n\n  handleDragSegment = (arrowId: string, index: number, pos: Position) => {\n    const arrow = this.state.widgets[arrowId] as ArrowWidget;\n    const horizontalDrag = arrowIsHorizontal(arrow)\n      ? index % 2 !== 0\n      : index % 2 === 0;\n    // if it's the first or last segment, create a new node\n    if (index === 0 || index === arrow.points.length - 1) {\n      return;\n    } else {\n      if (horizontalDrag) {\n        arrow.points[index].x = pos.x;\n        arrow.points[index + 1].x = pos.x;\n      } else {\n        arrow.points[index].y = pos.y;\n        arrow.points[index + 1].y = pos.y;\n      }\n    }\n    this.setState({ widgets: { ...this.state.widgets, [arrowId]: arrow} });\n  }\n\n  handleDragSegmentEnd = (arrowId: string, index: number, position?: number) => {\n    const arrow = this.state.widgets[arrowId] as ArrowWidget;\n    const { points } = arrow;\n    const horizontalDrag = arrowIsHorizontal(arrow)\n      ? index % 2 !== 0\n      : index % 2 === 0;\n    // merge segments if they are in the same axis\n    if (horizontalDrag) {\n      if (arrow.points[index].x === arrow.points[index - 1].x) {\n        arrow.points.splice(index, 2);\n      } else if (arrow.points[index + 1].x === arrow.points[index + 2].x) {\n        arrow.points.splice(index + 1, 2);\n      }\n    } else {\n      if (arrow.points[index].y === arrow.points[index - 1].y) {\n        arrow.points.splice(index, 2);\n      } else if (arrow.points[index + 1].y === arrow.points[index + 2].y) {\n        arrow.points.splice(index + 1, 2);\n      }\n    }\n    const startType = this.getStartPointType(points);\n    const endType = this.getEndPointType(points);\n    arrow.points[0].type = startType;\n    arrow.points[points.length - 1].type = endType;\n    if (index === 1) this.setArrowChartBranch(arrow, this.state.widgets, false, position);\n    if (this.state.newSegment) {\n      arrow.startPoint = startType;\n      arrow.endPoint = endType;\n      this.updateArrow(arrow);\n    }\n    this.setState({ widgets: { ...this.state.widgets, [arrowId]: arrow}, newSegment: false });\n  }\n\n  // finds if this arrow should be a part of a branchChart\n  setArrowChartBranch(arrow: ArrowWidget, widgets: Record<string, Widget>, dragging: boolean, position?: number) {\n    if(!this.state.settings.stickToConvergentWidgetSide && arrow.chartBranch) {\n      // don't recalculate if chartBranchSide and position didn't change\n      let convergencePoint = arrow.chartBranch.type === \"manyToOne\" ? arrow.points[arrow.points.length - 1] : arrow.points[0];\n      if(convergencePoint.type === arrow.chartBranch.convergenceSide && (!position || arrow.chartBranch.position === position)) {\n        console.log('not recalculating chart branch');\n        return;\n      }\n    }\n    \n    const chartBranchArrow = this.getSharedChartBranchArrow(arrow, widgets);\n    // don't force chartBranching while dragging on an empty side of the origin/end widget\n    // or if arrow has explicitly set start or end point\n    if((dragging && !chartBranchArrow) || arrow.points.length === 2) {\n      arrow.arrowType = 'initial';\n      arrow.chartBranch = null;\n      console.log('setting chart branch null');\n      return;\n    }\n\n    arrow.arrowType = \"chartBranch\";\n    \n    if(chartBranchArrow && chartBranchArrow.chartBranch && !position) {\n      console.log('become part of an existing chartBranch');\n      // become part of an existing chartBranch\n      if(chartBranchArrow.chartBranch.type === \"oneToOne\") {\n        // if we are just adding the 2nd arrow to this chartBranch, update type and convergenceSide beforehand\n        if(chartBranchArrow.start === arrow.start ){\n          chartBranchArrow.chartBranch.type = \"oneToMany\";\n          chartBranchArrow.chartBranch.convergenceSide = arrow.points[0].type;\n        } else {\n          chartBranchArrow.chartBranch.type = \"manyToOne\";\n          chartBranchArrow.chartBranch.convergenceSide = arrow.points[arrow.points.length - 1].type;\n        }\n      }\n      arrow.chartBranch = Object.assign({}, chartBranchArrow.chartBranch);\n    } else if ((!arrow.startPoint && !arrow.endPoint) || position) {\n      // new lonely charBranch arrow\n      console.log('new lonely charBranch arrow');\n      let chartBranch: ChartBranch = {\n        position: position || 0,\n        convergenceSide: arrow.points[0].type,\n        type: \"oneToOne\"\n      };\n      // on new branch, set 2nd segment position to half the distance in X or Y depending on orientation\n      // unless explicit position is passed as parameter\n      if (!position) {\n        console.log('convergenceSide: ', chartBranch.convergenceSide);\n        if(toOrientation(chartBranch.convergenceSide || 'right') === \"horizontal\") {\n          chartBranch.position = arrow.points[0].x + ((arrow.points[arrow.points.length - 1].x - arrow.points[0].x) / 2);\n        } else {\n          chartBranch.position = arrow.points[0].y + ((arrow.points[arrow.points.length - 1].y - arrow.points[0].y) / 2);\n        }\n      }\n      arrow.chartBranch = chartBranch;\n    }\n  }\n\n  // find another arrow that share same origin or end point and already has chartBranch defined\n  getSharedChartBranchArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    const chartBranchArrows = Object.values(widgets)\n    .filter(\n      (w) =>\n      w.type === \"arrow\" &&\n      w.id !== arrow.id &&\n      w.arrowType === \"chartBranch\" &&\n      w.chartBranch &&\n      ((w.start === arrow.start && w.points[0].type === arrow.points[0].type) ||\n       (w.end === arrow.end && w.points[w.points.length - 1].type === arrow.points[arrow.points.length - 1].type))\n    ).map(w => w as ArrowWidget);\n    \n    return chartBranchArrows.length > 0 ? chartBranchArrows[0] : null;\n  }\n\n  // updates arrow points (start/end) in both position and type\n  // draggingPosition is undefined when the arrow is connected to a start and\n  // end widget\n  // if it's not undefined, it means it's a disconnected arrow\n  updateArrow(arrow: ArrowWidget, draggingPosition?: Position) {\n    const { widgets } = this.state;\n    const startWidget = widgets[arrow.start || \"\"];\n    const endWidget = widgets[arrow.end || \"\"];\n    const isDisconnectedArrow = !!draggingPosition;\n\n    const connectedWidget = startWidget ? startWidget : endWidget;\n    if (!connectedWidget) return;\n\n    const points = [...arrow.points];\n\n    // stick to your branch side\n    if(!this.state.settings.stickToConvergentWidgetSide || arrow.arrowType !== \"chartBranch\") {\n      // change connections depending on positioning\n      const draggingX = draggingPosition ? draggingPosition.x : endWidget.x;\n      const draggingY = draggingPosition ? draggingPosition.y : endWidget.y;\n      const draggingWidth = draggingPosition ? 0 : endWidget.width;\n      const draggingHeight = draggingPosition ? 0 : endWidget.height;\n      if (points.length < 5) {\n        if (arrow.initialIsHorizontal) {\n          if (connectedWidget.x + connectedWidget.width + TOLERANCE < draggingX) {\n            points[0].type = startWidget ? \"right\" : \"left\";\n            points[points.length - 1].type = startWidget ? \"left\" : \"right\";\n          } else if (draggingX + draggingWidth + TOLERANCE < connectedWidget.x) {\n            points[0].type = startWidget ? \"left\" : \"right\";\n            points[points.length - 1].type = startWidget ? \"right\" : \"left\";\n          } else if (draggingY > connectedWidget.y + connectedWidget.height) {\n            points[0].type = startWidget ? \"bottom\" : \"top\";\n            points[points.length - 1].type = startWidget ? \"top\" : \"bottom\";\n          } else {\n            points[0].type = startWidget ? \"top\" : \"bottom\";\n            points[points.length - 1].type = startWidget ? \"bottom\" : \"top\";\n          }\n        } else {\n          if (connectedWidget.y + connectedWidget.height + TOLERANCE < draggingY) {\n            points[0].type = startWidget ? \"bottom\" : \"top\";\n            points[points.length - 1].type = startWidget ? \"top\" : \"bottom\";\n          } else if (draggingY + draggingHeight + TOLERANCE < connectedWidget.y) {\n            points[0].type = startWidget ? \"top\" : \"bottom\";\n            points[points.length - 1].type = startWidget ? \"bottom\" : \"top\";\n          } else if (draggingX > connectedWidget.x + connectedWidget.width) {\n            points[0].type = startWidget ? \"right\" : \"left\";\n            points[points.length - 1].type = startWidget ? \"left\" : \"right\";\n          } else {\n            points[0].type = startWidget ? \"left\" : \"right\";\n            points[points.length - 1].type = startWidget ? \"right\" : \"left\";\n          }\n        }\n        // it the connector starts / ends where it should automatically,\n        // don't force startPoint / endPoint any more\n        if (arrow.startPoint) {\n          if (arrow.startPoint === points[0].type) {\n            arrow.startPoint = null;\n          } else {\n            points[0].type = arrow.startPoint;\n          }\n        }\n        if (arrow.endPoint) {\n          if (arrow.endPoint === points[points.length - 1].type) {\n            arrow.endPoint = null;\n          } else {\n            points[points.length - 1].type = arrow.endPoint;\n          }\n        }\n      }\n\n\n      points[0] = startWidget ? this.getWidgetSideMidPosition(points[0], startWidget) : {...points[0], x: (draggingPosition as Position).x, y: (draggingPosition as Position).y};\n      points[points.length - 1] = endWidget ? this.getWidgetSideMidPosition(points[points.length - 1], endWidget) : {...points[points.length - 1], x: (draggingPosition as Position).x, y: (draggingPosition as Position).y};\n      arrow.points = points;\n      \n      // check if being a chartSide arrow\n      if(this.isChartSideArrow(arrow, widgets) && points.length < 5) {\n        console.log('IS CHART SIDE ARROW');\n        if (isDisconnectedArrow) {\n          this.updateArrowChartSide(arrow, connectedWidget, endWidget, draggingPosition, !!endWidget);\n        } else {\n          this.updateArrowChartSide(arrow, startWidget, endWidget);\n        }\n      }\n\n      // snap the two points while creating an arrow\n      if (isDisconnectedArrow && arrow.points.length < 5) {\n        const points = arrow.points;\n        if (points[0].type === 'left' || points[0].type === 'right') {\n          if (points[points.length - 1].y <= points[0].y + SNAPPING_DISTANCE && points[points.length - 1].y >= points[0].y - SNAPPING_DISTANCE) {\n            points[points.length - 1].y = points[0].y;\n          }\n        } else if (points[0].type === 'top' || points[0].type === 'bottom') {\n          if (points[points.length - 1].x <= points[0].x + SNAPPING_DISTANCE && points[points.length - 1].x >= points[0].x - SNAPPING_DISTANCE) {\n            points[points.length - 1].x = points[0].x;\n          }\n        }\n      }\n      \n      // check if being part of a chartBranch\n      this.setArrowChartBranch(arrow, widgets, true);\n    }\n    \n    // update chartBranch arrows\n    // this is mainly used for a branched arrow whose widget is \"behind\" the branch fixed position \n    if(arrow.chartBranch && startWidget && endWidget && points.length < 5) {\n      // on \"oneOnOne\" we consider the start widget as the convergent one\n      const convergesOnEnd = arrow.chartBranch.type === \"manyToOne\"; \n      let convergencePoint = convergesOnEnd ? arrow.points[arrow.points.length - 1] : arrow.points[0];\n      let nonConvergencePoint = convergesOnEnd ? arrow.points[0] : arrow.points[arrow.points.length - 1];\n      const convergentWidget = convergesOnEnd ? endWidget : startWidget;\n      const nonConvergentWidget = convergesOnEnd ? startWidget : endWidget;\n      \n      convergencePoint = this.getWidgetSideMidPosition(convergencePoint, convergentWidget);\n      nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n    \n      if(toOrientation(arrow.chartBranch.convergenceSide || 'right') === \"horizontal\") {\n        // if inside, use 2-segment arrow\n        if(arrow.chartBranch.position >= nonConvergentWidget.x && arrow.chartBranch.position <= nonConvergentWidget.x + nonConvergentWidget.width) {\n          nonConvergencePoint.x = arrow.chartBranch.position;\n          nonConvergencePoint.y = (nonConvergentWidget.y + nonConvergentWidget.height/2) > convergencePoint.y ? nonConvergentWidget.y : nonConvergentWidget.y + nonConvergentWidget.height;\n        // otherwise use regular 3-segment arrow but make sure it connects to the correct side\n        } else {\n          nonConvergencePoint.type = arrow.chartBranch.position < nonConvergentWidget.x ? \"left\" : \"right\";\n          nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n        }\n      } else {  // vertical\n        // if inside, use 2-segment arrow\n        if(arrow.chartBranch.position >= nonConvergentWidget.y && arrow.chartBranch.position <= nonConvergentWidget.y + nonConvergentWidget.height) {\n          nonConvergencePoint.x = (nonConvergentWidget.x + nonConvergentWidget.width/2) > convergencePoint.x ? nonConvergentWidget.x : nonConvergentWidget.x + nonConvergentWidget.width;\n          nonConvergencePoint.y = arrow.chartBranch.position;\n        // otherwise use regular 3-segment arrow but make sure it connects to the correct side\n        } else {\n          nonConvergencePoint.type = arrow.chartBranch.position < nonConvergentWidget.y ? \"top\" : \"bottom\";\n          nonConvergencePoint = this.getWidgetSideMidPosition(nonConvergencePoint, nonConvergentWidget);\n        }\n      }\n\n      arrow.points[0] = convergesOnEnd ? nonConvergencePoint : convergencePoint;\n      arrow.points[arrow.points.length - 1] = convergesOnEnd ? convergencePoint : nonConvergencePoint;\n    }\n    this.setIntermidiatePoints(arrow);\n  }\n\n  setIntermidiatePoints = (arrow: ArrowWidget) => {\n    const { points } = arrow;\n    const start = points[0];\n    const end = points[points.length - 1];\n    const isHorizontalStart = start.type === \"right\" || start.type === \"left\";\n    const isHorizontalEnd = end.type === \"right\" || end.type === \"left\";\n    const midDistance = isHorizontalStart ? (end.x - start.x) / 2 : (end.y - start.y) / 2;\n    // 1-segment straight line\n    if((isHorizontalStart && start.y === end.y) || (!isHorizontalStart && start.x === end.x)) {\n      if (points.length < 5) {\n        arrow.points = [start, end];\n        arrow.arrowType = 'initial';\n        arrow.chartBranch = null;\n        return;\n      }\n    }\n    let p2, p3, p4;\n    // 2-segments line\n    if (isHorizontalStart !== isHorizontalEnd && points.length < 5) {\n      const willCoverContent = isHorizontalStart\n        ? (end.type === \"bottom\" && end.y > start.y) || (end.type === \"top\" && end.y < start.y)\n        : (end.type === \"right\" && end.x > start.x) || (end.type === \"left\" && end.x < start.x);\n      if (!willCoverContent) {\n        const middlePoint = isHorizontalStart\n          ? { x: end.x, y: start.y }\n          : { x: start.x, y: end.y };\n        arrow.points = [start, middlePoint, end];\n        return;\n      } else { // 4-segments line\n        p2 = isHorizontalStart\n        ? { x: start.x + midDistance, y: start.y }\n        : { x: start.x, y: start.y + midDistance };\n      if (end.type === \"bottom\" || end.type === \"right\") {\n        p3 = isHorizontalStart\n          ? { x: start.x + midDistance, y: end.y + 20 }\n          : { x: end.x + 20, y: start.y + midDistance };\n        p4 = isHorizontalStart\n          ? { x: end.x, y: end.y + 20 }\n          : { x: end.x + 20, y: end.y };\n      } else {\n        p3 = isHorizontalStart\n          ? { x: start.x + midDistance, y: end.y - 20 }\n          : { x: end.x - 20, y: start.y + midDistance };\n        p4 = isHorizontalStart\n          ? { x: end.x, y: end.y - 20 }\n          : { x: end.x - 20, y: end.y };\n      }\n      arrow.points = [start, p2, p3, p4, end];\n      return;\n      }\n    }\n    // 4+ segments line\n    if (points.length >= 5) {\n      p2 = isHorizontalStart\n        ? { x: points[1].x, y: start.y }\n        : { x: start.x, y: points[1].y };\n      p4 = isHorizontalEnd\n        ? { x: points[points.length - 2].x, y: end.y }\n        : { x: end.x, y: points[points.length - 2].y };\n      const unalteredPoints = points.slice(2, points.length - 2);\n      arrow.points = [start, p2, ...unalteredPoints, p4, end];\n      return;\n    }\n    // const willCoverContent = isHorizontalStart\n    //   ? (end.type === \"right\" && end.x > start.x) || (end.type === \"left\" && end.x < start.x)\n    //   : (end.type === \"bottom\" && end.y > start.y) || (end.type === \"top\" && end.y < start.y);\n    //   // 3-segments line\n    //   if (willCoverContent && !arrow.chartBranch && points.length < 5) {\n    //     if (end.type === \"bottom\" || end.type === \"right\") {\n    //       p2 = isHorizontalStart\n    //         ? {x: end.x + 20, y: start.y}\n    //         : {x: start.x, y: end.y + 20};\n    //       p3 = isHorizontalStart\n    //         ? {x: end.x + 20, y: end.y}\n    //         : {x: end.x, y: end.y + 20};\n    //     } else {\n    //       p2 = isHorizontalStart\n    //         ? {x: end.x - 20, y: start.y}\n    //         :  {x: start.x, y: end.y - 20};\n    //       p3 = isHorizontalStart\n    //         ? {x: end.x - 20, y: end.y}\n    //         :  {x: end.x, y: end.y - 20};\n    //     }\n    //     arrow.points = [start, p2, p3, end];\n    //     return;\n    //   }\n\n    // 3 segments line\n    let segment2Position = isHorizontalStart\n      ? start.x + midDistance\n      : start.y + midDistance;\n\n    if(arrow.chartBranch) {\n      const convergenceTarget = arrow.chartBranch.type === \"manyToOne\" ? end : start;\n      if(arrow.chartBranch.convergenceSide === convergenceTarget.type) {\n        segment2Position = arrow.chartBranch.position;\n      }\n    }\n\n    p2 = isHorizontalStart\n      ? { x: segment2Position, y: start.y}\n      : { x: start.x, y: segment2Position};\n    p3 = isHorizontalStart\n      ? { x: segment2Position, y: end.y}\n      : { x: end.x, y: segment2Position};\n\n    arrow.points = [start, p2, p3, end];\n    return;\n  }\n  \n  isChartSideArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    // can't be chartSide if there is any chartBranch on current side\n    if(this.getSharedChartBranchArrow(arrow, widgets)) return false;\n    // can't be chartSide if their point were intentionally positioned\n    if (arrow.startPoint || arrow.endPoint) return false;\n    console.log('initialIsHorizontal: ', arrow.initialIsHorizontal);\n    return ((arrow.initialIsHorizontal && (arrow.points[0].type === \"top\" || arrow.points[0].type === \"bottom\")) ||\n    (!arrow.initialIsHorizontal && (arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\")));\n  }\n\n  // returns true if using intersection chartSide\n  updateArrowChartSide(arrow: ArrowWidget, startWidget: Widget, endWidget: Widget, draggingPosition?: Position, isStart?: boolean) {\n    if (arrow.points.length >= 5) return;\n    const draggingX = draggingPosition ? draggingPosition.x : endWidget.x;\n    const draggingY = draggingPosition ? draggingPosition.y : endWidget.y;\n    const draggingWidth = draggingPosition ? 0 : endWidget.width;\n    const draggingHeight = draggingPosition ? 0 : endWidget.height;\n    // if widgets limits are intersecting, use chartSide connector\n    if(arrow.initialIsHorizontal) {\n      console.log('CASE 1');\n      const middleX = this.getIntersectionMiddle(startWidget.x, startWidget.width, draggingX, draggingWidth);\n      if(middleX) {\n        arrow.points = [{ ...arrow.points[0], x: middleX }, {...arrow.points[arrow.points.length - 1], x: middleX }]\n        return true;\n      }\n    } else {\n      console.log('CASE 2');\n      const middleY = this.getIntersectionMiddle(startWidget.y, startWidget.height, draggingY, draggingHeight);\n      if(middleY) {\n        arrow.points = [{ ...arrow.points[0], y: middleY }, {...arrow.points[arrow.points.length - 1], y: middleY }]\n        return true;\n      }\n    }\n\n    // if there is no intersection, use original axis side\n    if (isStart && draggingPosition) {\n      if(arrow.initialIsHorizontal) {\n        arrow.points[arrow.points.length - 1].type = draggingX > startWidget.x + (startWidget.width / 2) ? \"right\" : \"left\";\n      } else {\n        arrow.points[arrow.points.length - 1].type = draggingY > startWidget.y + (startWidget.height / 2) ? \"bottom\" : \"top\";\n      }\n      arrow.points[arrow.points.length - 1] = this.getWidgetSideMidPosition(arrow.points[arrow.points.length - 1], startWidget);\n    } else {\n      if(arrow.initialIsHorizontal) {\n        arrow.points[0].type = draggingX > startWidget.x + (startWidget.width / 2) ? \"right\" : \"left\";\n      } else {\n        arrow.points[0].type = draggingY > startWidget.y + (startWidget.height / 2) ? \"bottom\" : \"top\";\n      }\n      arrow.points[0] = this.getWidgetSideMidPosition(arrow.points[0], startWidget);\n    }\n    \n    const startWidgetCenter = {x: startWidget.x + (startWidget.width/2), y: startWidget.y + (startWidget.height/2)};\n    const endWidgetCenter = {x: draggingX + (draggingWidth/2), y: draggingY + (draggingHeight/2)};\n    const distX = Math.abs(startWidgetCenter.x - endWidgetCenter.x) - (startWidget.width/2 + draggingWidth/2);\n    const distY = Math.abs(startWidgetCenter.y - endWidgetCenter.y) - (startWidget.height/2 + draggingHeight/2);\n    const widgetsTooClose = arrow.initialIsHorizontal ? distX <= ARROW_MARGIN : distY <= ARROW_MARGIN;\n    \n    // if widgets are too close, use 2-segments arrow\n    if(widgetsTooClose) {\n      // never closer than 20px from origin and never less than 10px from target side\n      if (isStart) {\n        if(arrow.initialIsHorizontal) {\n          arrow.points[0].type = draggingY > arrow.points[arrow.points.length - 1].y ? \"top\" : \"bottom\";\n          let distXToCenter = startWidget.width/2 + Math.max(distX + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n          arrow.points[0].x = startWidgetCenter.x + (arrow.points[arrow.points.length - 1].type === \"right\" ? distXToCenter : -distXToCenter);\n          arrow.points[0].y = arrow.points[0].type === \"top\" ? draggingY : draggingY + draggingHeight;\n        } else {\n          arrow.points[0].type = draggingX > arrow.points[arrow.points.length - 1].x ? \"left\" : \"right\";\n          let distYToCenter = startWidget.height/2 + Math.max(distY + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n          arrow.points[0].x = arrow.points[arrow.points.length - 1].type === \"left\" ? draggingX : draggingX + draggingWidth;\n          arrow.points[0].y = startWidgetCenter.y + (arrow.points[arrow.points.length - 1].type === \"bottom\" ? distYToCenter : -distYToCenter);\n        }\n      } else {\n        if(arrow.initialIsHorizontal) {\n          arrow.points[arrow.points.length - 1].type = draggingY > arrow.points[0].y ? \"top\" : \"bottom\";\n          let distXToCenter = startWidget.width/2 + Math.max(distX + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n          arrow.points[arrow.points.length - 1].x = startWidgetCenter.x + (arrow.points[0].type === \"right\" ? distXToCenter : -distXToCenter);\n          arrow.points[arrow.points.length - 1].y = arrow.points[arrow.points.length - 1].type === \"top\" ? draggingY : draggingY + draggingHeight;\n        } else {\n          arrow.points[arrow.points.length - 1].type = draggingX > arrow.points[0].x ? \"left\" : \"right\";\n          let distYToCenter = startWidget.height/2 + Math.max(distY + ARROW_MARGIN, TWO_SEGMENT_ARROW_MIN);\n          arrow.points[arrow.points.length - 1].x = arrow.points[arrow.points.length - 1].type === \"left\" ? draggingX : draggingX + draggingWidth;\n          arrow.points[arrow.points.length - 1].y = startWidgetCenter.y + (arrow.points[0].type === \"bottom\" ? distYToCenter : -distYToCenter);\n        }\n      }\n    // otherwise use regular 3-segments arrow\n    } else {\n      if (isStart) {\n        if(arrow.initialIsHorizontal) {\n          arrow.points[0].type = arrow.points[arrow.points.length - 1].type === \"right\" ? \"left\" : \"right\";\n        } else {\n          arrow.points[0].type = arrow.points[arrow.points.length - 1].type === \"bottom\" ? \"top\" : \"bottom\";\n        }\n        arrow.points[0] = draggingPosition ? {...arrow.points[0], x: draggingPosition.x, y: draggingPosition.y} : this.getWidgetSideMidPosition(arrow.points[0], endWidget);\n      } else {\n        if(arrow.initialIsHorizontal) {\n            arrow.points[arrow.points.length - 1].type = arrow.points[0].type === \"right\" ? \"left\" : \"right\";\n        } else {\n          arrow.points[arrow.points.length - 1].type = arrow.points[0].type === \"bottom\" ? \"top\" : \"bottom\";\n        }\n        arrow.points[arrow.points.length - 1] = draggingPosition ? {...arrow.points[arrow.points.length - 1], x: draggingPosition.x, y: draggingPosition.y} : this.getWidgetSideMidPosition(arrow.points[arrow.points.length - 1], endWidget);\n      }\n    }\n\n    return false;\n  }\n\n  // returns the middle point of an intersection\n  getIntersectionMiddle(min1: number, size1: number, min2: number, size2: number) {\n    const max1 = min1 + size1;\n    const max2 = min2 + size2;\n    if (size2 === 0) return min2 >= min1 && min2 <= max1 ? min2 : null;\n\n    // TODO: none of this works when moving endWidget\n    // TODO: make sure this works with different shaped widgets\n    // if((this.between(min1, min2, max2) && this.between(max1, min2, max2)) ||\n    //    (this.between(min2, min1, max1) && this.between(max2, min1, max1))) {\n    if((min1 === min2 && max1 === max2) ||\n      (min1 > min2 && min1 < max2)) {\n      const intersection = max2 - min1;\n      if(intersection <= ARROW_MARGIN * 2) return null;\n      \n      return min1 + (intersection / 2);\n    } else if(max1 > min2 && max1 < max2) {\n      const intersection = max1 - min2;\n      if(intersection <= ARROW_MARGIN * 2) return null;\n\n      return max1 - (intersection / 2);\n    }\n\n    // no intersection\n    return null;\n  }\n\n  between(value: number, min: number, max: number) {\n    return value>min && value<max;\n  }\n  \n  getWidgetSideMidPosition(point: Point, widget: Widget) {\n    let newPoint: Point = {type: point.type, x: 0, y: 0};\n    switch(point.type) {\n      case \"top\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y;\n        break;\n      case \"right\":\n        newPoint.x = widget.x + widget.width;\n        newPoint.y = widget.y + widget.height / 2;\n        break;\n      case \"bottom\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y + widget.height;\n        break;\n      case \"left\":\n        newPoint.x = widget.x;\n        newPoint.y = widget.y + widget.height / 2;\n        break;\n    }\n\n    return newPoint;\n  }\n\n  render() {\n    const { cursor, selected, widgets } = this.state;\n    return (\n      <div>\n        <div\n          id=\"canvas\"\n          style={{ cursor }}\n          className={`App ${cursor === 'crosshair' ? 'connector-mode' : ''}`}\n          tabIndex={1}\n          onDoubleClick={this.handleDoubleClick}\n          onKeyDown={this.handleKeyDown}\n          onMouseMove={this.handleDrag}\n          onMouseDown={this.handleMouseDown}\n          onMouseUp={this.handleMouseUp}\n          ref={this.handleRef}\n          >\n          {Object.values(widgets).map((w) => {\n            if (w.type === \"sticky\") {\n              return (\n                <Sticky\n                  cursor={cursor}\n                  onMouseDown={this.handleStickyMouseDown}\n                  onMouseUp={this.handleStickyMouseUp}\n                  onDragStart={this.handleWidgetDragStart}\n                  onMouseHover={this.handleMouseHoverSticky}\n                  onMouseLeave={this.handleMouseLeaveSticky}\n                  selected={!!selected?.includes(w.id)}\n                  widget={w}\n                  key={w.id}\n                />\n                );\n            }\n            \n            if (w.type === \"arrow\") {\n              return <Arrow\n                widget={w}\n                key={w.id}\n                onDragPointStart={this.handleArrowPointDragStart}\n                onDragSegmentEnd={this.handleDragSegmentEnd}\n                onDragSegment={this.handleDragSegment}\n                onDragSegmentStart={this.handleDragSementStart}\n                showLabels={this.state.settings.showLabels}\n              />;\n            }\n            \n            return null;\n          })}\n        </div>\n        <div id=\"settings\" style={settingsStyle}>\n          <Checkbox\n            label=\"Stick To Convergent Widget Side\"\n            onCheckedChange={this.handleCheckStick} />\n          <hr />\n          <Checkbox\n            label=\"Show labels\"\n            onCheckedChange={this.handleCheckLabels} />\n        </div>\n      </div>\n    );\n  }\n\n  handleCheckStick = (checked: boolean) => {\n    const settings = { ...this.state.settings, stickToConvergentWidgetSide: checked };\n    this.setState({ settings });\n  }\n\n  handleCheckLabels = (checked: boolean) => {\n    const settings = { ...this.state.settings, showLabels: checked };\n    this.setState({ settings });\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}