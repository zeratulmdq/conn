{"version":3,"sources":["widgets/Sticky.tsx","widgets/Arrow.tsx","App.tsx","types.ts","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleContextMenu","e","props","onContextMenu","widget","id","handleDragStart","clientX","clientY","handleDragMove","onDrag","x","y","handleDragEnd","this","cursor","onMouseDown","onMouseMove","onMouseUp","style","top","left","className","React","PureComponent","Arrow","position","pointerEvents","xmlns","version","points","start","end","type","d","stroke","strokeWidth","fill","cx","cy","r","midDistanceX","d1","d2","d3","midDistanceY","pathGenerator","App","ref","state","initialId","widgets","preventDefault","stopPropagation","setState","prevState","spec","startWidget","endWidget","arrow","uuid","height","width","relation","Math","abs","handleDoubleClick","s","handleDrag","draggingWidgetId","dragged","connected","Object","values","filter","w","reduce","acc","cur","flecha","startPoint","endPoint","handleRef","window","sarlanga","onDoubleClick","map","key","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.fcbef36d.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onContextMenu: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDrag: (id: string, spec: Partial<StickyWidget>) => void;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.PureComponent<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onContextMenu, widget } = this.props;\n\n    onContextMenu(widget.id, e);\n  };\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    this.dragging = true;\n    this.initialX = e.clientX;\n    this.initialY = e.clientY;\n  };\n\n  handleDragMove = (e: React.MouseEvent<HTMLDivElement>) => {\n    if (!this.dragging) return;\n\n    const { onDrag, widget } = this.props;\n\n    onDrag(widget.id, {\n      x: e.clientX - this.initialX + widget.x,\n      y: e.clientY - this.initialY + widget.y,\n    });\n\n    this.initialX = e.clientX;\n    this.initialY = e.clientY;\n  };\n\n  handleDragEnd = (e: React.MouseEvent<HTMLDivElement>) => {\n    this.dragging = false;\n  };\n\n  render() {\n    const {\n      cursor,\n      widget: { x, y },\n    } = this.props;\n    return (\n      <div\n        onContextMenu={this.handleContextMenu}\n        onMouseDown={this.handleDragStart}\n        onMouseMove={this.handleDragMove}\n        onMouseUp={this.handleDragEnd}\n        style={{\n          top: y,\n          left: x,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n        }}\n        className=\"Sticky\"\n      />\n    );\n  }\n}\n\nexport default Sticky;\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport { ArrowWidget, Point } from \"../types\";\n\ninterface PropTypes {\n  widget: ArrowWidget;\n}\n\nconst pathGenerator = (points: Point[]) => {\n  const start = points[0];\n  const end = points[1];\n\n  if (start.type === \"right\" || start.type === \"left\") {\n    if (start.y === end.y) {\n      const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n      return [\n        <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n        <circle\n          cx={`${end.x}`}\n          cy={`${end.y}`}\n          r=\"5\"\n          stroke=\"#5cb85c\"\n          fill=\"#5cb85c\"\n        ></circle>,\n      ];\n    }\n\n    const midDistanceX = (end.x - start.x) / 2;\n\n    const d1 = `M ${start.x} ${start.y} L ${start.x + midDistanceX} ${start.y}`;\n    const d2 = `M ${start.x + midDistanceX} ${start.y} L ${\n      start.x + midDistanceX\n    } ${end.y}`;\n    const d3 = `M ${start.x + midDistanceX} ${end.y} L ${end.x} ${end.y}`;\n\n    return [\n      <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <circle\n        cx={`${end.x}`}\n        cy={`${end.y}`}\n        r=\"5\"\n        stroke=\"#5cb85c\"\n        fill=\"#5cb85c\"\n      ></circle>,\n    ];\n  }\n\n  if (start.x === end.x) {\n    const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n    return [\n      <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <circle\n        cx={`${end.x}`}\n        cy={`${end.y}`}\n        r=\"5\"\n        stroke=\"#5cb85c\"\n        fill=\"#5cb85c\"\n      ></circle>,\n    ];\n  }\n\n  const midDistanceY = (end.y - start.y) / 2;\n\n  const d1 = `M ${start.x} ${start.y} L ${start.x} ${start.y + midDistanceY}`;\n  const d2 = `M ${start.x} ${start.y + midDistanceY} L ${end.x} ${\n    start.y + midDistanceY\n  }`;\n  const d3 = `M ${end.x} ${start.y + midDistanceY} L ${end.x} ${end.y}`;\n\n  return [\n    <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <circle\n      cx={`${end.x}`}\n      cy={`${end.y}`}\n      r=\"5\"\n      stroke=\"#5cb85c\"\n      fill=\"#5cb85c\"\n    ></circle>,\n  ];\n};\n\nclass Arrow extends React.PureComponent<PropTypes> {\n  render() {\n    return (\n      <svg\n        style={{ position: \"absolute\", top: 0, left: 0, pointerEvents: \"none\" }}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        version=\"1.1\"\n      >\n        {pathGenerator(this.props.widget.points)}\n      </svg>\n    );\n  }\n}\n\nexport default Arrow;\n","import React from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n} from \"./types\";\nimport Arrow from \"./widgets/Arrow\";\n\nexport const TOLERANCE = 10;\n\ninterface State {\n  cursor: React.CSSProperties[\"cursor\"];\n  initialId: string | null;\n  widgets: Record<string, Widget>;\n}\n\nclass App extends React.PureComponent<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    cursor: \"auto\",\n    initialId: null,\n    widgets: {},\n  };\n\n  constructor(props: any) {\n    super(props);\n\n    (window as any).sarlanga = this;\n  }\n\n  handleContextMenu = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (!this.state.initialId) {\n      this.setState({\n        initialId: id,\n        cursor: \"crosshair\",\n      });\n      return;\n    }\n\n    if (this.state.initialId === id) {\n      this.setState({\n        initialId: null,\n        cursor: \"auto\",\n      });\n      return;\n    }\n\n    this.setState((prevState) => {\n      const startWidget = prevState.widgets[prevState.initialId || \"\"];\n      const endWidget = prevState.widgets[id];\n      const points: Point[] = [];\n      const arrow = {\n        ...arrowFactory({ start: prevState.initialId, end: id }),\n        points,\n      };\n      // relation > 1 horizontal line\n      const relation = Math.abs(\n        (startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)\n      );\n\n      if (startWidget.x + startWidget.width + TOLERANCE < endWidget.x) {\n        if (relation > 1) {\n          points[0] = {\n            x: startWidget.x + startWidget.width,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"right\",\n          };\n          points[1] = {\n            x: endWidget.x,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"left\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      } else {\n        if (relation > 1) {\n          points[0] = {\n            x: startWidget.x,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"left\",\n          };\n          points[1] = {\n            x: endWidget.x + endWidget.width,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"right\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      }\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        initialId: null,\n        widgets: {\n          ...prevState.widgets,\n          [arrow.id]: arrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    const s = stickyFactory({ x: e.clientX, y: e.clientY });\n    this.setState((prevState) => ({\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (draggingWidgetId: string, spec: Partial<StickyWidget>) => {\n    this.setState((prevState) => {\n      const dragged = {\n        ...prevState.widgets[draggingWidgetId],\n        ...spec,\n      } as StickyWidget;\n\n      const connected = Object.values(prevState.widgets)\n        .filter(\n          (w) =>\n            w.type === \"arrow\" &&\n            (w.start === draggingWidgetId || w.end === draggingWidgetId)\n        )\n        .reduce((acc, cur) => {\n          const flecha = cur as ArrowWidget;\n          const startWidget = prevState.widgets[\n            flecha.start || \"\"\n          ] as StickyWidget;\n\n          const startPoint = flecha.points[0];\n          const endPoint = flecha.points[1];\n\n          if (flecha.end === draggingWidgetId) {\n            if (startPoint.type === \"right\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y + startWidget.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n              }\n            }\n\n            if (startPoint.type === \"left\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x - TOLERANCE < endPoint.x) {\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y + startWidget.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n              }\n            }\n\n            // If start point is bottom, it means endpoint is top, trust me.\n            if (startPoint.type === \"bottom\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: startWidget.x + startWidget.width,\n                  y: startWidget.y + startWidget.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: startWidget.x,\n                  y: startWidget.y + startWidget.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n              }\n            }\n\n            if (startPoint.type === \"top\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y - TOLERANCE > endPoint.y) {\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: startWidget.x + startWidget.width,\n                  y: startWidget.y + startWidget.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: startWidget.x,\n                  y: startWidget.y + startWidget.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n              }\n            }\n          }\n\n          if (flecha.start === draggingWidgetId) {\n            const endWidget = prevState.widgets[\n              flecha.end || \"\"\n            ] as StickyWidget;\n\n            if (startPoint.type === \"right\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y + endWidget.height,\n                };\n              }\n            }\n\n            if (startPoint.type === \"left\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x - TOLERANCE > endPoint.x) {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y + endWidget.height,\n                };\n              }\n            }\n\n            // If start point is bottom, it means endpoint is top, trust me.\n            if (startPoint.type === \"bottom\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: endWidget.x,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: endWidget.x + endWidget.width,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n              }\n            }\n\n            if (startPoint.type === \"top\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y - TOLERANCE > endPoint.y) {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: endWidget.x,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: endWidget.x + endWidget.width,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n              }\n            }\n          }\n\n          return {\n            ...acc,\n            [flecha.id]: {\n              ...flecha,\n            },\n          };\n        }, {} as Record<string, Widget>);\n\n      return {\n        widgets: {\n          ...prevState.widgets,\n          [draggingWidgetId]: dragged,\n          ...connected,\n        },\n      };\n    });\n  };\n\n  handleRef = (ref: HTMLDivElement) => (this.ref = ref);\n\n  render() {\n    const { cursor, widgets } = this.state;\n    return (\n      <div\n        style={{ cursor }}\n        className=\"App\"\n        onDoubleClick={this.handleDoubleClick}\n        ref={this.handleRef}\n      >\n        {Object.values(widgets).map((w) => {\n          if (w.type === \"sticky\") {\n            return (\n              <Sticky\n                cursor={cursor}\n                onContextMenu={this.handleContextMenu}\n                onDrag={this.handleDrag}\n                widget={w}\n                key={w.id}\n              />\n            );\n          }\n\n          if (w.type === \"arrow\") {\n            return <Arrow widget={w} key={w.id} />;\n          }\n\n          return null;\n        })}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type: PointType;\n}\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  end: string | null;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: 100,\n  width: 100,\n  type: \"sticky\",\n  x: (spec.x || 0) - 50,\n  y: (spec.y || 0) - 50,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n});\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}