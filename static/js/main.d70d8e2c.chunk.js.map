{"version":3,"sources":["widgets/Sticky.tsx","types.ts","widgets/Arrow.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleContextMenu","e","props","onContextMenu","onRightClick","widget","id","handleDragStart","onDragStart","this","cursor","selected","x","y","width","height","onMouseDown","style","top","left","border","className","React","Component","stickyFactory","spec","uuid","type","arrowFactory","start","end","points","arrowType","chartBranchSide","chartBranchPosition","initialIsHorizontal","Arrow","position","pointerEvents","xmlns","version","isHorizontalConnection","d","stroke","strokeWidth","fill","cx","cy","r","midDistance","segment2Position","p1","p2","p3","p4","d1","d2","d3","pathGenerator","PureComponent","App","ref","state","initialId","lastX","lastY","widgets","handleRightClick","preventDefault","stopPropagation","cancelArrowCreation","handleStickyRightClick","setState","prevState","startWidget","endWidget","Math","abs","arrow","updateArrowChartBranch","handleDoubleClick","s","clientX","clientY","handleDrag","dragged","connectedArrows","Object","values","filter","w","reduce","acc","cur","updateArrow","button","handleKeyDown","key","prevWidgets","forEach","handleMouseDown","handleMouseUp","map","isChartSideArrow","updateArrowChartSide","handleRef","ignoreLoneSide","chartBranchArrow","getSharedChartBranch","find","connectedArrow","draggingWidgetId","draggingWidget","startPoint","endPoint","getArrowPointMidPosition","middleX","getIntersectionMiddle","middleY","min1","size1","min2","size2","max1","max2","point","newPoint","tabIndex","onDoubleClick","onKeyDown","onMouseMove","onMouseUp","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.d70d8e2c.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onRightClick: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDragStart: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  selected: boolean;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.Component<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onRightClick: onContextMenu, widget } = this.props;\n\n    onContextMenu(widget.id, e);\n  };\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onDragStart, widget } = this.props;\n\n    onDragStart(widget.id, e);\n  };\n\n  render() {\n    const {\n      cursor,\n      selected,\n      widget: { x, y , width, height},\n    } = this.props;\n    return (\n      <div\n        onContextMenu={this.handleContextMenu}\n        onMouseDown={this.handleDragStart}\n        style={{\n          top: y,\n          left: x,\n          width: width,\n          height: height,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n          border: selected ? \"2px solid blue\" : \"none\",\n        }}\n        className=\"Sticky\"\n      />\n    );\n  }\n}\n\nexport default Sticky;\n","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type: PointType;\n}\n\n// initial: initial simple arrow, centered to the connected widgets on both ends, bent into 3 segments having the same length in both parallel segments.\n// chartBranch: created from an 'initial' arrow, centered to the connected widgets on both ends, bent into 3 segments, can share inital segment with other 'chartBranch' arrows, 1st segment size stays put.\n// chartSide: created from an 'initial' arrow, moved to the side of a group of 'chartBranch' arrows and can be on any point of both connected widgets.\nexport type ArrowType = \"initial\" | \"chartBranch\" | \"chartSide\";\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  end: string | null;\n  arrowType: ArrowType;\n  chartBranchSide: PointType | null;\n  chartBranchPosition: number | null;\n  initialIsHorizontal: boolean;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: 100,\n  width: 100,\n  type: \"sticky\",\n  x: (spec.x || 0) - 50,\n  y: (spec.y || 0) - 50,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n  arrowType: \"initial\",\n  chartBranchSide: null,\n  chartBranchPosition: null,\n  initialIsHorizontal: true,\n});\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport { ArrowWidget, Point, PointType } from \"../types\";\n\ninterface PropTypes {\n  widget: ArrowWidget;\n}\n\nconst pathGenerator = (points: Point[], chartBranchSide: PointType | null, chartBranchPosition: number | null) => {\n  const start = points[0];\n  const end = points[1];\n  const isHorizontalConnection = start.type === \"right\" || start.type === \"left\";\n\n  // straight line\n  if((isHorizontalConnection && start.y === end.y) ||\n    (!isHorizontalConnection && start.x === end.x)) {\n      const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n      return [\n        <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n        <circle\n          cx={`${end.x}`}\n          cy={`${end.y}`}\n          r=\"5\"\n          stroke=\"#5cb85c\"\n          fill=\"#5cb85c\"\n        ></circle>,\n      ];\n  }\n\n  // 3-segments line\n  const midDistance = isHorizontalConnection ? (end.x - start.x) / 2 : (end.y - start.y) / 2;\n  let segment2Position = isHorizontalConnection ? start.x + midDistance: start.y + midDistance;\n  if(chartBranchSide && chartBranchPosition && chartBranchSide === start.type) {\n    segment2Position = chartBranchPosition;\n  }\n\n  const p1 = `${start.x} ${start.y}`;\n  const p2 = isHorizontalConnection ? `${segment2Position} ${start.y}` : ` ${start.x} ${segment2Position}`;\n  const p3 = isHorizontalConnection ? `${segment2Position} ${end.y}` : ` ${end.x} ${segment2Position}`;\n  const p4 = `${end.x} ${end.y}`;\n\n  const d1 = `M ${p1} L ${p2}`;\n  const d2 = `M ${p2} L ${p3}`;\n  const d3 = `M ${p3} L ${p4}`;\n\n  return [\n    <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <circle\n      cx={`${end.x}`}\n      cy={`${end.y}`}\n      r=\"5\"\n      stroke=\"#5cb85c\"\n      fill=\"#5cb85c\"\n    ></circle>,\n  ];\n};\n\nclass Arrow extends React.PureComponent<PropTypes> {\n  render() {\n    return (\n      <svg\n        style={{ position: \"absolute\", top: 0, left: 0, pointerEvents: \"none\" }}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        version=\"1.1\"\n      >\n        {pathGenerator(this.props.widget.points, this.props.widget.chartBranchSide, this.props.widget.chartBranchPosition)}\n      </svg>\n    );\n  }\n}\n\nexport default Arrow;\n","import React from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n} from \"./types\";\nimport Arrow from \"./widgets/Arrow\";\n\nexport const TOLERANCE = 10;\n\ninterface State {\n  cursor: React.CSSProperties[\"cursor\"];\n  dragging: string | null;\n  initialId: string | null;\n  initialX: number | null;\n  initialY: number | null;\n  lastX: number | null;\n  lastY: number | null;\n  selected: string | null;\n  widgets: Record<string, Widget>;\n}\n\nclass App extends React.Component<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    cursor: \"auto\",\n    dragging: null,\n    initialId: null,\n    initialX: null,\n    initialY: null,\n    lastX: null,\n    lastY: null,\n    selected: null,\n    widgets: {},\n  };\n\n  cancelArrowCreation() {\n      this.setState({\n        initialId: null,\n        cursor: \"auto\",\n      });\n  }\n  \n  handleRightClick = (e: React.MouseEvent<HTMLDivElement>) => { \n    e.preventDefault();\n    e.stopPropagation();\n\n    if (this.state.initialId) {\n      this.cancelArrowCreation();\n    }\n  }\n\n  handleStickyRightClick = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    // start arrow creation\n    if (!this.state.initialId) {\n      this.setState({\n        initialId: id,\n        cursor: \"crosshair\",\n      });\n      return;\n    }\n\n    if (this.state.initialId === id) {\n      this.cancelArrowCreation();\n      return;\n    }\n\n    this.setState((prevState) => {\n      const startWidget = prevState.widgets[prevState.initialId || \"\"];\n      const endWidget = prevState.widgets[id];\n      const points: Point[] = [];\n      const isHorizontalConnection = Math.abs(\n        (startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)\n      ) > 1;\n\n      const arrow = {\n        ...arrowFactory({ start: prevState.initialId, end: id }),\n        points,\n        initialIsHorizontal: isHorizontalConnection,\n      };\n\n      if (startWidget.x + startWidget.width + TOLERANCE < endWidget.x) {\n        if (isHorizontalConnection) {\n          points[0] = {\n            x: startWidget.x + startWidget.width,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"right\",\n          };\n          points[1] = {\n            x: endWidget.x,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"left\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      } else {\n        if (isHorizontalConnection) {\n          points[0] = {\n            x: startWidget.x,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"left\",\n          };\n          points[1] = {\n            x: endWidget.x + endWidget.width,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"right\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      }\n      \n      this.updateArrowChartBranch(arrow, prevState.widgets, true);\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        initialId: null,\n        widgets: {\n          ...prevState.widgets,\n          [arrow.id]: arrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    const s = stickyFactory({ x: e.clientX, y: e.clientY });\n    this.setState((prevState) => ({\n      selected: s.id,\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX, clientY } = e;\n    this.setState((prevState) => {\n      if (!prevState.dragging || !prevState.lastX || !prevState.lastY)\n        return { ...prevState };\n      const dragged = {\n        ...prevState.widgets[prevState.dragging],\n      } as StickyWidget;\n\n      dragged.x = dragged.x + clientX - prevState.lastX;\n      dragged.y = dragged.y + clientY - prevState.lastY;\n\n      const connectedArrows = Object.values(prevState.widgets)\n        .filter(\n          (w) =>\n            w.type === \"arrow\" &&\n            (w.start === prevState.dragging || w.end === prevState.dragging)\n        )\n        .reduce((acc, cur) => {\n          const arrow = cur as ArrowWidget;\n          this.updateArrow(arrow, prevState.widgets, prevState.dragging, dragged);\n\n          this.updateArrowChartBranch(arrow, prevState.widgets, true);\n\n          return {\n            ...acc,\n            [arrow.id]: {\n              ...arrow,\n            },\n          };\n        }, {} as Record<string, Widget>);\n\n      return {\n        lastX: clientX,\n        lastY: clientY,\n        widgets: {\n          ...prevState.widgets,\n          [dragged.id]: dragged,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleDragStart = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX: initialX, clientY: initialY } = e;\n    e.stopPropagation();\n\n    if (e.button !== 0) return;\n\n    this.setState({\n      dragging: id,\n      selected: id,\n      initialX: initialX,\n      initialY: initialY,\n      lastX: initialX,\n      lastY: initialY,\n    });\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if ((e.key === \"Backspace\" || e.key === \"Delete\") && this.state.selected) {\n      this.setState((prevState) => {\n        const id = prevState.selected || \"\";\n        const prevWidgets = prevState.widgets;\n        delete prevWidgets[id];\n\n        Object.values(prevWidgets).forEach((w) => {\n          if (w.type === \"arrow\" && (w.start === id || w.end === id))\n            delete prevWidgets[w.id];\n        });\n        return {\n          ...prevState,\n          selected: null,\n          widgets: { ...prevWidgets },\n        };\n      });\n    }\n  };\n\n  handleMouseDown = () => {\n    this.setState({ selected: null });\n  };\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    this.setState((prevState) => {\n      \n      if (!prevState.dragging)\n        return { ...prevState };\n      \n      const connectedArrows = Object.values(prevState.widgets)\n      .filter(\n        (w) =>\n          w.type === \"arrow\" &&\n          (w.start === prevState.dragging || w.end === prevState.dragging)\n      ).map(w=> w as ArrowWidget)\n      .reduce((acc, arrow) => {\n\n        if(this.isChartSideArrow(arrow, prevState.widgets)) {\n          const startWidget = prevState.widgets[arrow.start || \"\"] as StickyWidget;\n          const endWidget = prevState.widgets[arrow.end || \"\"] as StickyWidget;\n          this.updateArrowChartSide(arrow, startWidget, endWidget);\n          arrow.arrowType = \"chartSide\";\n          // swap axis for new chartSide creation\n          arrow.initialIsHorizontal = !arrow.initialIsHorizontal;\n        }\n        \n        if(arrow.end === prevState.dragging) {\n          this.updateArrowChartBranch(arrow, prevState.widgets, false);\n        }\n\n        return {\n          ...acc,\n          [arrow.id]: {\n            ...arrow,\n          },\n        };\n      }, {} as Record<string, Widget>);\n      \n      return {\n        dragging: null,\n        widgets: {\n          ...prevState.widgets,\n          ...connectedArrows,\n        },\n      };\n    });\n  };\n\n  handleRef = (ref: HTMLDivElement) => (this.ref = ref);\n\n  updateArrowChartBranch(arrow: ArrowWidget, widgets: Record<string, Widget>, ignoreLoneSide: boolean) {\n    // if(arrow.arrowType === \"chartSide\") return;\n\n    // don't recalculate if chartBranchSide didn't change\n    if(!arrow.chartBranchSide || arrow.chartBranchSide !== arrow.points[0].type) {\n      \n      const chartBranchArrow = this.getSharedChartBranch(arrow, widgets);\n      // don't force chartBranching while dragging on a new side of the origin widget\n      if(ignoreLoneSide && !chartBranchArrow) return;\n        \n      // console.log(`updateArrowChartBranch originType: ${arrow.points[0].type} chartBranchArrow: ${chartBranchArrow}  chartBranchPosition: ${chartBranchArrow?.chartBranchPosition}`)\n      arrow.arrowType = \"chartBranch\";\n      arrow.chartBranchSide = arrow.points[0].type;\n      if(chartBranchArrow) {\n        arrow.chartBranchPosition = chartBranchArrow.chartBranchPosition;\n      } else {\n        // fix 2nd segment position to X or Y depending on orientation of the arrow\n        if(arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\") {\n          arrow.chartBranchPosition = arrow.points[0].x + ((arrow.points[1].x - arrow.points[0].x) / 2);\n        } else {\n          arrow.chartBranchPosition = arrow.points[0].y + ((arrow.points[1].y - arrow.points[0].y) / 2);\n        }\n      }\n    }\n  }\n\n  // find another arrow that share same origin point and already has chartBranchPosition fixed\n  getSharedChartBranch(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    // all arrows connected to \"start\" widget\n    const originArrows = Object.values(widgets)\n    .filter(\n      (w) =>\n        w.type === \"arrow\" &&\n        (w.start === arrow.start)\n    ).map(w=> w as ArrowWidget);\n\n    return originArrows.find(connectedArrow =>\n      connectedArrow !== arrow &&\n      connectedArrow.arrowType === \"chartBranch\" &&\n      connectedArrow.points[0].type === arrow.points[0].type &&\n      connectedArrow.chartBranchPosition);\n  }\n  \n  // updates arrow points (start/end) in both position and type\n  updateArrow(arrow: ArrowWidget, widgets: Record<string, Widget>, draggingWidgetId: string | null, draggingWidget: StickyWidget) {\n    const startPoint = arrow.points[0];\n    const endPoint = arrow.points[1];\n    \n    const startWidget = arrow.start === draggingWidgetId ? draggingWidget :\n    widgets[arrow.start || \"\"] as StickyWidget;\n    const endWidget = arrow.end === draggingWidgetId ? draggingWidget :\n    widgets[arrow.end || \"\"] as StickyWidget;\n\n    // initial dummy values\n    let points: Point[] = [{type: startPoint.type, x: 0, y: 0}, {type: endPoint.type, x: 1, y: 0}];\n\n    if (arrow.end === draggingWidgetId) {\n\n      if (startPoint.type === \"right\") {\n        // If the start.x + tolerance is lower than end.x, we keep things\n        // as they are\n        if (startPoint.x + TOLERANCE < endPoint.x) {\n          points[1].type = \"left\";\n          // Else, we check which point is higher so we can switch our point\n          // types and re-order the connections\n        } else if (startPoint.y + TOLERANCE < endPoint.y) {\n          points[0].type = \"bottom\";\n          points[1].type = \"top\";\n          // Final else, it's the only remaining option\n        } else {\n          points[0].type = \"top\";\n          points[1].type = \"bottom\";\n        }\n      }\n\n      if (startPoint.type === \"left\") {\n        // If the start.x + tolerance is lower than end.x, we keep things\n        // as they are\n        if (startPoint.x - TOLERANCE < endPoint.x) {\n          points[1].type = \"right\";\n          // Else, we check which point is higher so we can swith our point\n          // types and re-order the connections\n        } else if (startPoint.y + TOLERANCE < endPoint.y) {\n          points[0].type = \"bottom\";\n          points[1].type = \"top\";\n          // Final else, it's the only remaining option\n        } else {\n          points[0].type = \"top\";\n          points[1].type = \"bottom\";\n        }\n      }\n\n      // If start point is bottom, it means endpoint is top, trust me.\n      if (startPoint.type === \"bottom\") {\n        // If the start.y + tolerance is lower than end.y, we keep things\n        // as they are\n        if (startPoint.y + TOLERANCE < endPoint.y) {\n          points[1].type = \"top\";\n          // Else, we check if the start point is \"lefter\" than the end\n          // point\n        } else if (startPoint.x + TOLERANCE < endPoint.x) {\n          points[0].type = \"right\";\n          points[1].type = \"left\";\n          // Finally, we know the start point is \"righter\" than the end one\n        } else {\n          points[0].type = \"left\";\n          points[1].type = \"right\";\n        }\n      }\n\n      if (startPoint.type === \"top\") {\n        // If the start.y + tolerance is lower than end.y, we keep things\n        // as they are\n        if (startPoint.y - TOLERANCE > endPoint.y) {\n          points[1].type = \"bottom\";\n          // Else, we check if the start point is \"lefter\" than the end\n          // point\n        } else if (startPoint.x + TOLERANCE < endPoint.x) {\n          points[0].type = \"right\";\n          points[1].type = \"left\";\n          // Finally, we know the start point is \"righter\" than the end one\n        } else {\n          points[0].type = \"left\";\n          points[1].type = \"right\";\n        }\n      }\n    }\n\n    if (arrow.start === draggingWidgetId) {\n\n      if (startPoint.type === \"right\") {\n        // If the start.x + tolerance is lower than end.x, we keep things\n        // as they are\n        if (startPoint.x + TOLERANCE < endPoint.x) {\n          points[0].type = \"right\";\n          // Else, we check which point is higher so we can swith our point\n          // types and re-order the connections\n        } else if (startPoint.y + TOLERANCE < endPoint.y) {\n          points[0].type = \"bottom\";\n          points[1].type = \"top\";\n          // Final else, it's the only remaining option\n        } else {\n          points[0].type = \"top\";\n          points[1].type = \"bottom\";\n        }\n      }\n\n      if (startPoint.type === \"left\") {\n        // If the start.x + tolerance is lower than end.x, we keep things\n        // as they are\n        if (startPoint.x - TOLERANCE > endPoint.x) {\n          points[0].type = \"left\";\n          // Else, we check which point is higher so we can switch our point\n          // types and re-order the connections\n        } else if (startPoint.y + TOLERANCE < endPoint.y) {\n          points[0].type = \"bottom\";\n          points[1].type = \"top\";\n          // Final else, it's the only remaining option\n        } else {\n          points[0].type = \"top\";\n          points[1].type = \"bottom\";\n        }\n      }\n\n      // If start point is bottom, it means endpoint is top, trust me.\n      if (startPoint.type === \"bottom\") {\n        // If the start.y + tolerance is lower than end.y, we keep things\n        // as they are\n        if (startPoint.y + TOLERANCE < endPoint.y) {\n          points[0].type = \"bottom\";\n          // Else, we check if the start point is \"lefter\" than the end\n          // point\n        } else if (startPoint.x + TOLERANCE < endPoint.x) {\n          points[0].type = \"right\";\n          points[1].type = \"left\";\n          // Finally, we know the start point is \"righter\" than the end one\n        } else {\n          points[0].type = \"left\";\n          points[1].type = \"right\";\n        }\n      }\n\n      if (startPoint.type === \"top\") {\n        // If the start.y + tolerance is lower than end.y, we keep things\n        // as they are\n        if (startPoint.y - TOLERANCE > endPoint.y) {\n          points[0].type = \"top\";\n          // Else, we check if the start point is \"lefter\" than the end\n          // point\n        } else if (startPoint.x + TOLERANCE < endPoint.x) {\n          points[0].type = \"right\";\n          points[1].type = \"left\";\n          // Finally, we know the start point is \"righter\" than the end one\n        } else {\n          points[0].type = \"left\";\n          points[1].type = \"right\";\n        }\n      }\n    }\n\n    // chartBranch connector\n    points[0] = this.getArrowPointMidPosition(points[0], startWidget);\n    points[1] = this.getArrowPointMidPosition(points[1], endWidget);\n    arrow.points = points;\n\n    // charSide connector\n    if(this.isChartSideArrow(arrow, widgets)) {\n      this.updateArrowChartSide(arrow, startWidget, endWidget);\n    }\n  }\n\n  isChartSideArrow(arrow: ArrowWidget, widgets: Record<string, Widget>) {\n    // can't be chartSide if there is any chartBranch\n    if(this.getSharedChartBranch(arrow, widgets)) return;\n\n    // chartSide arrows can only be created from \"initial\" and \"chartSide\" arrows\n    return ((arrow.initialIsHorizontal && (arrow.points[0].type === \"top\" || arrow.points[0].type === \"bottom\")) ||\n    (!arrow.initialIsHorizontal && (arrow.points[0].type === \"left\" || arrow.points[0].type === \"right\")));\n  }\n\n  updateArrowChartSide(arrow: ArrowWidget, startWidget: StickyWidget, endWidget: StickyWidget) {\n    // chartSide connector\n    if(arrow.initialIsHorizontal) {\n      const middleX = this.getIntersectionMiddle(startWidget.x, startWidget.width, endWidget.x, endWidget.width);\n      if(middleX) {\n        arrow.points[0].x = middleX;\n        arrow.points[1].x = middleX;\n      }\n    } else {\n      const middleY = this.getIntersectionMiddle(startWidget.y, startWidget.height, endWidget.y, endWidget.height);\n      if(middleY) {\n        arrow.points[0].y = middleY;\n        arrow.points[1].y = middleY;\n      }\n    }\n  }\n\n  getIntersectionMiddle(min1: number, size1: number, min2: number, size2: number) {\n    const max1 = min1 + size1;\n    const max2 = min2 + size2;\n\n    if(min1 === min2 && max1 === max2) {\n      return 0;\n    }\n\n    // TODO: implement margin of 10\n    if((min1 > min2 && min1 < max2)) {\n      return min1 + ((max2 - min1) / 2);\n    } else if(max1 > min2 && max1 < max2) {\n      return max1 - ((max1 - min2) / 2);\n    }\n\n    // no intersection\n    return null;\n  }\n  \n  getArrowPointMidPosition(point: Point, widget: StickyWidget) {\n    let newPoint: Point = {type: point.type, x: 0, y: 0};\n    switch(point.type) {\n      case \"top\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y;\n        break;\n      case \"right\":\n        newPoint.x = widget.x + widget.width;\n        newPoint.y = widget.y + widget.height / 2;\n        break;\n      case \"bottom\":\n        newPoint.x = widget.x + widget.width / 2;\n        newPoint.y = widget.y + widget.height;\n        break;\n      case \"left\":\n        newPoint.x = widget.x;\n        newPoint.y = widget.y + widget.width / 2;\n        break;\n    }\n\n    return newPoint;\n  }\n\n  render() {\n    const { cursor, selected, widgets } = this.state;\n    return (\n      <div\n        style={{ cursor }}\n        className=\"App\"\n        tabIndex={1}\n        onContextMenu={this.handleRightClick}\n        onDoubleClick={this.handleDoubleClick}\n        onKeyDown={this.handleKeyDown}\n        onMouseMove={this.handleDrag}\n        onMouseDown={this.handleMouseDown}\n        onMouseUp={this.handleMouseUp}\n        ref={this.handleRef}\n      >\n        {Object.values(widgets).map((w) => {\n          if (w.type === \"sticky\") {\n            return (\n              <Sticky\n                cursor={cursor}\n                onRightClick={this.handleStickyRightClick}\n                onDragStart={this.handleDragStart}\n                selected={selected === w.id}\n                widget={w}\n                key={w.id}\n              />\n            );\n          }\n\n          if (w.type === \"arrow\") {\n            return <Arrow widget={w} key={w.id} />;\n          }\n\n          return null;\n        })}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}