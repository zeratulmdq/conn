{"version":3,"sources":["widgets/Sticky.tsx","types.ts","widgets/Arrow.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleContextMenu","e","props","onContextMenu","widget","id","handleDragStart","onDragStart","this","cursor","selected","x","y","onMouseDown","style","top","left","border","className","React","Component","stickyFactory","spec","uuid","height","width","type","arrowFactory","start","end","points","Arrow","position","pointerEvents","xmlns","version","d","stroke","strokeWidth","fill","cx","cy","r","midDistanceX","d1","d2","d3","midDistanceY","pathGenerator","PureComponent","App","ref","state","initialId","widgets","preventDefault","stopPropagation","setState","prevState","startWidget","endWidget","arrow","relation","Math","abs","handleDoubleClick","s","clientX","clientY","handleDrag","dragged","connected","Object","values","filter","w","reduce","acc","cur","flecha","startPoint","endPoint","button","handleKeyDown","key","prevWidgets","forEach","handleMouseDown","handleMouseUp","handleRef","tabIndex","onDoubleClick","onKeyDown","onMouseMove","onMouseUp","map","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.d357e80a.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onContextMenu: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDragStart: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  selected: boolean;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.Component<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onContextMenu, widget } = this.props;\n\n    onContextMenu(widget.id, e);\n  };\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onDragStart, widget } = this.props;\n\n    onDragStart(widget.id, e);\n  };\n\n  render() {\n    const {\n      cursor,\n      selected,\n      widget: { x, y },\n    } = this.props;\n    return (\n      <div\n        onContextMenu={this.handleContextMenu}\n        onMouseDown={this.handleDragStart}\n        style={{\n          top: y,\n          left: x,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n          border: selected ? \"2px solid blue\" : \"none\",\n        }}\n        className=\"Sticky\"\n      />\n    );\n  }\n}\n\nexport default Sticky;\n","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type: PointType;\n}\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  end: string | null;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: 100,\n  width: 100,\n  type: \"sticky\",\n  x: (spec.x || 0) - 50,\n  y: (spec.y || 0) - 50,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n});\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport { ArrowWidget, Point } from \"../types\";\n\ninterface PropTypes {\n  widget: ArrowWidget;\n}\n\nconst pathGenerator = (points: Point[]) => {\n  const start = points[0];\n  const end = points[1];\n\n  if (start.type === \"right\" || start.type === \"left\") {\n    if (start.y === end.y) {\n      const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n      return [\n        <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n        <circle\n          cx={`${end.x}`}\n          cy={`${end.y}`}\n          r=\"5\"\n          stroke=\"#5cb85c\"\n          fill=\"#5cb85c\"\n        ></circle>,\n      ];\n    }\n\n    const midDistanceX = (end.x - start.x) / 2;\n\n    const d1 = `M ${start.x} ${start.y} L ${start.x + midDistanceX} ${start.y}`;\n    const d2 = `M ${start.x + midDistanceX} ${start.y} L ${\n      start.x + midDistanceX\n    } ${end.y}`;\n    const d3 = `M ${start.x + midDistanceX} ${end.y} L ${end.x} ${end.y}`;\n\n    return [\n      <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <circle\n        cx={`${end.x}`}\n        cy={`${end.y}`}\n        r=\"5\"\n        stroke=\"#5cb85c\"\n        fill=\"#5cb85c\"\n      ></circle>,\n    ];\n  }\n\n  if (start.x === end.x) {\n    const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n    return [\n      <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <circle\n        cx={`${end.x}`}\n        cy={`${end.y}`}\n        r=\"5\"\n        stroke=\"#5cb85c\"\n        fill=\"#5cb85c\"\n      ></circle>,\n    ];\n  }\n\n  const midDistanceY = (end.y - start.y) / 2;\n\n  const d1 = `M ${start.x} ${start.y} L ${start.x} ${start.y + midDistanceY}`;\n  const d2 = `M ${start.x} ${start.y + midDistanceY} L ${end.x} ${\n    start.y + midDistanceY\n  }`;\n  const d3 = `M ${end.x} ${start.y + midDistanceY} L ${end.x} ${end.y}`;\n\n  return [\n    <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <circle\n      cx={`${end.x}`}\n      cy={`${end.y}`}\n      r=\"5\"\n      stroke=\"#5cb85c\"\n      fill=\"#5cb85c\"\n    ></circle>,\n  ];\n};\n\nclass Arrow extends React.PureComponent<PropTypes> {\n  render() {\n    return (\n      <svg\n        style={{ position: \"absolute\", top: 0, left: 0, pointerEvents: \"none\" }}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        version=\"1.1\"\n      >\n        {pathGenerator(this.props.widget.points)}\n      </svg>\n    );\n  }\n}\n\nexport default Arrow;\n","import React from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n} from \"./types\";\nimport Arrow from \"./widgets/Arrow\";\n\nexport const TOLERANCE = 10;\n\ninterface State {\n  cursor: React.CSSProperties[\"cursor\"];\n  dragging: string | null;\n  initialId: string | null;\n  initialX: number | null;\n  initialY: number | null;\n  selected: string | null;\n  widgets: Record<string, Widget>;\n}\n\nclass App extends React.Component<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    cursor: \"auto\",\n    dragging: null,\n    initialId: null,\n    initialX: null,\n    initialY: null,\n    selected: null,\n    widgets: {},\n  };\n\n  handleContextMenu = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (!this.state.initialId) {\n      this.setState({\n        initialId: id,\n        cursor: \"crosshair\",\n      });\n      return;\n    }\n\n    if (this.state.initialId === id) {\n      this.setState({\n        initialId: null,\n        cursor: \"auto\",\n      });\n      return;\n    }\n\n    this.setState((prevState) => {\n      const startWidget = prevState.widgets[prevState.initialId || \"\"];\n      const endWidget = prevState.widgets[id];\n      const points: Point[] = [];\n      const arrow = {\n        ...arrowFactory({ start: prevState.initialId, end: id }),\n        points,\n      };\n      // relation > 1 horizontal line\n      const relation = Math.abs(\n        (startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)\n      );\n\n      if (startWidget.x + startWidget.width + TOLERANCE < endWidget.x) {\n        if (relation > 1) {\n          points[0] = {\n            x: startWidget.x + startWidget.width,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"right\",\n          };\n          points[1] = {\n            x: endWidget.x,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"left\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      } else {\n        if (relation > 1) {\n          points[0] = {\n            x: startWidget.x,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"left\",\n          };\n          points[1] = {\n            x: endWidget.x + endWidget.width,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"right\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      }\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        initialId: null,\n        widgets: {\n          ...prevState.widgets,\n          [arrow.id]: arrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    const s = stickyFactory({ x: e.clientX, y: e.clientY });\n    this.setState((prevState) => ({\n      selected: s.id,\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX, clientY } = e;\n    this.setState((prevState) => {\n      if (!prevState.dragging || !prevState.initialX || !prevState.initialY)\n        return { ...prevState };\n      const dragged = {\n        ...prevState.widgets[prevState.dragging],\n      } as StickyWidget;\n\n      dragged.x = dragged.x + clientX - prevState.initialX;\n      dragged.y = dragged.y + clientY - prevState.initialY;\n\n      const connected = Object.values(prevState.widgets)\n        .filter(\n          (w) =>\n            w.type === \"arrow\" &&\n            (w.start === prevState.dragging || w.end === prevState.dragging)\n        )\n        .reduce((acc, cur) => {\n          const flecha = cur as ArrowWidget;\n          const startWidget = prevState.widgets[\n            flecha.start || \"\"\n          ] as StickyWidget;\n\n          const startPoint = flecha.points[0];\n          const endPoint = flecha.points[1];\n\n          if (flecha.end === prevState.dragging) {\n            if (startPoint.type === \"right\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y + startWidget.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n              }\n            }\n\n            if (startPoint.type === \"left\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x - TOLERANCE < endPoint.x) {\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y + startWidget.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n              }\n            }\n\n            // If start point is bottom, it means endpoint is top, trust me.\n            if (startPoint.type === \"bottom\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: startWidget.x + startWidget.width,\n                  y: startWidget.y + startWidget.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: startWidget.x,\n                  y: startWidget.y + startWidget.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n              }\n            }\n\n            if (startPoint.type === \"top\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y - TOLERANCE > endPoint.y) {\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: startWidget.x + startWidget.width,\n                  y: startWidget.y + startWidget.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: startWidget.x,\n                  y: startWidget.y + startWidget.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n              }\n            }\n          }\n\n          if (flecha.start === prevState.dragging) {\n            const endWidget = prevState.widgets[\n              flecha.end || \"\"\n            ] as StickyWidget;\n\n            if (startPoint.type === \"right\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y + endWidget.height,\n                };\n              }\n            }\n\n            if (startPoint.type === \"left\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x - TOLERANCE > endPoint.x) {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y + endWidget.height,\n                };\n              }\n            }\n\n            // If start point is bottom, it means endpoint is top, trust me.\n            if (startPoint.type === \"bottom\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: endWidget.x,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: endWidget.x + endWidget.width,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n              }\n            }\n\n            if (startPoint.type === \"top\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y - TOLERANCE > endPoint.y) {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: endWidget.x,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: endWidget.x + endWidget.width,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n              }\n            }\n          }\n\n          return {\n            ...acc,\n            [flecha.id]: {\n              ...flecha,\n            },\n          };\n        }, {} as Record<string, Widget>);\n\n      return {\n        initialX: clientX,\n        initialY: clientY,\n        widgets: {\n          ...prevState.widgets,\n          [dragged.id]: dragged,\n          ...connected,\n        },\n      };\n    });\n  };\n\n  handleDragStart = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX: initialX, clientY: initialY } = e;\n    e.stopPropagation();\n\n    if (e.button !== 0) return;\n\n    this.setState({\n      dragging: id,\n      selected: id,\n      initialX,\n      initialY,\n    });\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if ((e.key === \"Backspace\" || e.key === \"Delete\") && this.state.selected) {\n      this.setState((prevState) => {\n        const id = prevState.selected || \"\";\n        const prevWidgets = prevState.widgets;\n        delete prevWidgets[id];\n\n        Object.values(prevWidgets).forEach((w) => {\n          if (w.type === \"arrow\" && (w.start === id || w.end === id))\n            delete prevWidgets[w.id];\n        });\n        return {\n          ...prevState,\n          selected: null,\n          widgets: { ...prevWidgets },\n        };\n      });\n    }\n  };\n\n  handleMouseDown = () => {\n    this.setState({ selected: null });\n  };\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    this.setState({ dragging: null });\n  };\n\n  handleRef = (ref: HTMLDivElement) => (this.ref = ref);\n\n  render() {\n    const { cursor, selected, widgets } = this.state;\n    return (\n      <div\n        style={{ cursor }}\n        className=\"App\"\n        tabIndex={1}\n        onDoubleClick={this.handleDoubleClick}\n        onKeyDown={this.handleKeyDown}\n        onMouseMove={this.handleDrag}\n        onMouseDown={this.handleMouseDown}\n        onMouseUp={this.handleMouseUp}\n        ref={this.handleRef}\n      >\n        {Object.values(widgets).map((w) => {\n          if (w.type === \"sticky\") {\n            return (\n              <Sticky\n                cursor={cursor}\n                onContextMenu={this.handleContextMenu}\n                onDragStart={this.handleDragStart}\n                selected={selected === w.id}\n                widget={w}\n                key={w.id}\n              />\n            );\n          }\n\n          if (w.type === \"arrow\") {\n            return <Arrow widget={w} key={w.id} />;\n          }\n\n          return null;\n        })}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}