{"version":3,"sources":["widgets/Sticky.tsx","types.ts","widgets/Arrow.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Sticky","dragging","initialX","initialY","handleContextMenu","e","props","onContextMenu","widget","id","handleDragStart","onDragStart","this","cursor","x","y","onMouseDown","style","top","left","className","React","PureComponent","stickyFactory","spec","uuid","height","width","type","arrowFactory","start","end","points","Arrow","position","pointerEvents","xmlns","version","d","stroke","strokeWidth","fill","cx","cy","r","midDistanceX","d1","d2","d3","midDistanceY","pathGenerator","App","ref","state","initialId","widgets","preventDefault","stopPropagation","setState","prevState","startWidget","endWidget","arrow","relation","Math","abs","handleDoubleClick","s","clientX","clientY","handleDrag","dragged","connected","Object","values","filter","w","reduce","acc","cur","flecha","startPoint","endPoint","button","handleMouseUp","handleRef","onDoubleClick","onMouseMove","onMouseUp","map","key","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.6752d84a.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Sticky.css\";\nimport { StickyWidget } from \"../types\";\n\ninterface PropTypes {\n  cursor: React.CSSProperties[\"cursor\"];\n  onContextMenu: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  onDragStart: (id: string, e: React.MouseEvent<HTMLDivElement>) => void;\n  widget: StickyWidget;\n}\n\nclass Sticky extends React.PureComponent<PropTypes> {\n  dragging: boolean = false;\n  initialX: number = 0;\n  initialY: number = 0;\n\n  handleContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onContextMenu, widget } = this.props;\n\n    onContextMenu(widget.id, e);\n  };\n\n  handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { onDragStart, widget } = this.props;\n\n    onDragStart(widget.id, e);\n  };\n\n  render() {\n    const {\n      cursor,\n      widget: { x, y },\n    } = this.props;\n    return (\n      <div\n        onContextMenu={this.handleContextMenu}\n        onMouseDown={this.handleDragStart}\n        style={{\n          top: y,\n          left: x,\n          cursor: cursor === \"crosshair\" ? \"crosshair\" : \"pointer\",\n        }}\n        className=\"Sticky\"\n      />\n    );\n  }\n}\n\nexport default Sticky;\n","import * as uuid from \"uuid\";\n\ninterface W {\n  height: number;\n  width: number;\n  id: string;\n  x: number;\n  y: number;\n}\n\nexport type PointType = \"bottom\" | \"top\" | \"left\" | \"right\";\n\nexport interface Point {\n  x: number;\n  y: number;\n  type: PointType;\n}\n\nexport type StickyWidget = W & { type: \"sticky\" };\nexport type ArrowWidget = W & {\n  type: \"arrow\";\n  points: Point[];\n  start: string | null;\n  end: string | null;\n};\n\nexport type Widget = StickyWidget | ArrowWidget;\n\nexport const stickyFactory = (spec: Partial<StickyWidget>): StickyWidget => ({\n  id: uuid.v4(),\n  height: 100,\n  width: 100,\n  type: \"sticky\",\n  x: (spec.x || 0) - 50,\n  y: (spec.y || 0) - 50,\n});\n\nexport const arrowFactory = (spec: Partial<ArrowWidget>): ArrowWidget => ({\n  id: uuid.v4(),\n  height: 0,\n  width: 0,\n  type: \"arrow\",\n  x: (spec.x || 0) - 25,\n  y: (spec.y || 0) - 25,\n  start: spec.start || null,\n  end: spec.end || null,\n  points: [],\n});\n","import React from \"react\";\nimport \"./Sticky.css\";\nimport { ArrowWidget, Point } from \"../types\";\n\ninterface PropTypes {\n  widget: ArrowWidget;\n}\n\nconst pathGenerator = (points: Point[]) => {\n  const start = points[0];\n  const end = points[1];\n\n  if (start.type === \"right\" || start.type === \"left\") {\n    if (start.y === end.y) {\n      const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n      return [\n        <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n        <circle\n          cx={`${end.x}`}\n          cy={`${end.y}`}\n          r=\"5\"\n          stroke=\"#5cb85c\"\n          fill=\"#5cb85c\"\n        ></circle>,\n      ];\n    }\n\n    const midDistanceX = (end.x - start.x) / 2;\n\n    const d1 = `M ${start.x} ${start.y} L ${start.x + midDistanceX} ${start.y}`;\n    const d2 = `M ${start.x + midDistanceX} ${start.y} L ${\n      start.x + midDistanceX\n    } ${end.y}`;\n    const d3 = `M ${start.x + midDistanceX} ${end.y} L ${end.x} ${end.y}`;\n\n    return [\n      <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <circle\n        cx={`${end.x}`}\n        cy={`${end.y}`}\n        r=\"5\"\n        stroke=\"#5cb85c\"\n        fill=\"#5cb85c\"\n      ></circle>,\n    ];\n  }\n\n  if (start.x === end.x) {\n    const d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;\n    return [\n      <path d={d} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n      <circle\n        cx={`${end.x}`}\n        cy={`${end.y}`}\n        r=\"5\"\n        stroke=\"#5cb85c\"\n        fill=\"#5cb85c\"\n      ></circle>,\n    ];\n  }\n\n  const midDistanceY = (end.y - start.y) / 2;\n\n  const d1 = `M ${start.x} ${start.y} L ${start.x} ${start.y + midDistanceY}`;\n  const d2 = `M ${start.x} ${start.y + midDistanceY} L ${end.x} ${\n    start.y + midDistanceY\n  }`;\n  const d3 = `M ${end.x} ${start.y + midDistanceY} L ${end.x} ${end.y}`;\n\n  return [\n    <path d={d1} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d2} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <path d={d3} stroke=\"red\" strokeWidth=\"2\" fill=\"none\" />,\n    <circle\n      cx={`${end.x}`}\n      cy={`${end.y}`}\n      r=\"5\"\n      stroke=\"#5cb85c\"\n      fill=\"#5cb85c\"\n    ></circle>,\n  ];\n};\n\nclass Arrow extends React.PureComponent<PropTypes> {\n  render() {\n    return (\n      <svg\n        style={{ position: \"absolute\", top: 0, left: 0, pointerEvents: \"none\" }}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        version=\"1.1\"\n      >\n        {pathGenerator(this.props.widget.points)}\n      </svg>\n    );\n  }\n}\n\nexport default Arrow;\n","import React from \"react\";\nimport \"./App.css\";\nimport Sticky from \"./widgets/Sticky\";\nimport {\n  stickyFactory,\n  Widget,\n  StickyWidget,\n  ArrowWidget,\n  arrowFactory,\n  Point,\n} from \"./types\";\nimport Arrow from \"./widgets/Arrow\";\n\nexport const TOLERANCE = 10;\n\ninterface State {\n  cursor: React.CSSProperties[\"cursor\"];\n  dragging: string | null;\n  initialId: string | null;\n  initialX: number | null;\n  initialY: number | null;\n  widgets: Record<string, Widget>;\n}\n\nclass App extends React.PureComponent<{}, State> {\n  ref: HTMLDivElement | null = null;\n\n  state: State = {\n    cursor: \"auto\",\n    dragging: null,\n    initialId: null,\n    initialX: null,\n    initialY: null,\n    widgets: {},\n  };\n\n  handleContextMenu = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (!this.state.initialId) {\n      this.setState({\n        initialId: id,\n        cursor: \"crosshair\",\n      });\n      return;\n    }\n\n    if (this.state.initialId === id) {\n      this.setState({\n        initialId: null,\n        cursor: \"auto\",\n      });\n      return;\n    }\n\n    this.setState((prevState) => {\n      const startWidget = prevState.widgets[prevState.initialId || \"\"];\n      const endWidget = prevState.widgets[id];\n      const points: Point[] = [];\n      const arrow = {\n        ...arrowFactory({ start: prevState.initialId, end: id }),\n        points,\n      };\n      // relation > 1 horizontal line\n      const relation = Math.abs(\n        (startWidget.x - endWidget.x) / (startWidget.y - endWidget.y)\n      );\n\n      if (startWidget.x + startWidget.width + TOLERANCE < endWidget.x) {\n        if (relation > 1) {\n          points[0] = {\n            x: startWidget.x + startWidget.width,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"right\",\n          };\n          points[1] = {\n            x: endWidget.x,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"left\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      } else {\n        if (relation > 1) {\n          points[0] = {\n            x: startWidget.x,\n            y: startWidget.y + startWidget.height / 2,\n            type: \"left\",\n          };\n          points[1] = {\n            x: endWidget.x + endWidget.width,\n            y: endWidget.y + endWidget.height / 2,\n            type: \"right\",\n          };\n        } else {\n          if (startWidget.y + startWidget.height + TOLERANCE < endWidget.y) {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y + startWidget.height,\n              type: \"bottom\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y,\n              type: \"top\",\n            };\n          } else {\n            points[0] = {\n              x: startWidget.x + startWidget.width / 2,\n              y: startWidget.y,\n              type: \"top\",\n            };\n            points[1] = {\n              x: endWidget.x + endWidget.width / 2,\n              y: endWidget.y + endWidget.height,\n              type: \"bottom\",\n            };\n          }\n        }\n      }\n\n      return {\n        ...prevState,\n        cursor: \"auto\",\n        initialId: null,\n        widgets: {\n          ...prevState.widgets,\n          [arrow.id]: arrow,\n        },\n      };\n    });\n  };\n\n  handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    const s = stickyFactory({ x: e.clientX, y: e.clientY });\n    this.setState((prevState) => ({\n      widgets: {\n        ...prevState.widgets,\n        [s.id]: s,\n      },\n    }));\n  };\n\n  handleDrag = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX, clientY } = e;\n    this.setState((prevState) => {\n      if (!prevState.dragging || !prevState.initialX || !prevState.initialY)\n        return { ...prevState };\n      const dragged = {\n        ...prevState.widgets[prevState.dragging],\n      } as StickyWidget;\n\n      dragged.x = dragged.x + clientX - prevState.initialX;\n      dragged.y = dragged.y + clientY - prevState.initialY;\n\n      const connected = Object.values(prevState.widgets)\n        .filter(\n          (w) =>\n            w.type === \"arrow\" &&\n            (w.start === prevState.dragging || w.end === prevState.dragging)\n        )\n        .reduce((acc, cur) => {\n          const flecha = cur as ArrowWidget;\n          const startWidget = prevState.widgets[\n            flecha.start || \"\"\n          ] as StickyWidget;\n\n          const startPoint = flecha.points[0];\n          const endPoint = flecha.points[1];\n\n          if (flecha.end === prevState.dragging) {\n            if (startPoint.type === \"right\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y + startWidget.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n              }\n            }\n\n            if (startPoint.type === \"left\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x - TOLERANCE < endPoint.x) {\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y + startWidget.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: startWidget.x + startWidget.width / 2,\n                  y: startWidget.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n              }\n            }\n\n            // If start point is bottom, it means endpoint is top, trust me.\n            if (startPoint.type === \"bottom\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: startWidget.x + startWidget.width,\n                  y: startWidget.y + startWidget.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: startWidget.x,\n                  y: startWidget.y + startWidget.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n              }\n            }\n\n            if (startPoint.type === \"top\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y - TOLERANCE > endPoint.y) {\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: startWidget.x + startWidget.width,\n                  y: startWidget.y + startWidget.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: startWidget.x,\n                  y: startWidget.y + startWidget.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n              }\n            }\n          }\n\n          if (flecha.start === prevState.dragging) {\n            const endWidget = prevState.widgets[\n              flecha.end || \"\"\n            ] as StickyWidget;\n\n            if (startPoint.type === \"right\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y + endWidget.height,\n                };\n              }\n            }\n\n            if (startPoint.type === \"left\") {\n              // If the start.x + tolerance is lower than end.x, we keep things\n              // as they are\n              if (startPoint.x - TOLERANCE > endPoint.x) {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.height / 2,\n                };\n                // Else, we check which point is higher so we can swith our point\n                // types and re-order the connections\n              } else if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                flecha.points[1] = {\n                  type: \"top\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y,\n                };\n                // Final else, it's the only remaining option\n              } else {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                flecha.points[1] = {\n                  type: \"bottom\",\n                  x: endWidget.x + endWidget.width / 2,\n                  y: endWidget.y + endWidget.height,\n                };\n              }\n            }\n\n            // If start point is bottom, it means endpoint is top, trust me.\n            if (startPoint.type === \"bottom\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y + TOLERANCE < endPoint.y) {\n                flecha.points[0] = {\n                  type: \"bottom\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y + dragged.height,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: endWidget.x,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: endWidget.x + endWidget.width,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n              }\n            }\n\n            if (startPoint.type === \"top\") {\n              // If the start.y + tolerance is lower than end.y, we keep things\n              // as they are\n              if (startPoint.y - TOLERANCE > endPoint.y) {\n                flecha.points[0] = {\n                  type: \"top\",\n                  x: dragged.x + dragged.width / 2,\n                  y: dragged.y,\n                };\n                // Else, we check if the start point is \"lefter\" than the end\n                // point\n              } else if (startPoint.x + TOLERANCE < endPoint.x) {\n                flecha.points[0] = {\n                  type: \"right\",\n                  x: dragged.x + dragged.width,\n                  y: dragged.y + dragged.height / 2,\n                };\n                flecha.points[1] = {\n                  type: \"left\",\n                  x: endWidget.x,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n                // Finally, we know the start point is \"righter\" than the end one\n              } else {\n                flecha.points[0] = {\n                  type: \"left\",\n                  x: dragged.x,\n                  y: dragged.y + dragged.width / 2,\n                };\n                flecha.points[1] = {\n                  type: \"right\",\n                  x: endWidget.x + endWidget.width,\n                  y: endWidget.y + endWidget.height / 2,\n                };\n              }\n            }\n          }\n\n          return {\n            ...acc,\n            [flecha.id]: {\n              ...flecha,\n            },\n          };\n        }, {} as Record<string, Widget>);\n\n      return {\n        initialX: clientX,\n        initialY: clientY,\n        widgets: {\n          ...prevState.widgets,\n          [dragged.id]: dragged,\n          ...connected,\n        },\n      };\n    });\n  };\n\n  handleDragStart = (id: string, e: React.MouseEvent<HTMLDivElement>) => {\n    const { clientX: initialX, clientY: initialY } = e;\n\n    if (e.button !== 0) return;\n\n    this.setState({\n      dragging: id,\n      initialX,\n      initialY,\n    });\n  };\n\n  handleMouseUp = (e: React.MouseEvent<HTMLDivElement>) => {\n    this.setState({ dragging: null });\n  };\n\n  handleRef = (ref: HTMLDivElement) => (this.ref = ref);\n\n  render() {\n    const { cursor, widgets } = this.state;\n    return (\n      <div\n        style={{ cursor }}\n        className=\"App\"\n        onDoubleClick={this.handleDoubleClick}\n        onMouseMove={this.handleDrag}\n        onMouseUp={this.handleMouseUp}\n        ref={this.handleRef}\n      >\n        {Object.values(widgets).map((w) => {\n          if (w.type === \"sticky\") {\n            return (\n              <Sticky\n                cursor={cursor}\n                onContextMenu={this.handleContextMenu}\n                onDragStart={this.handleDragStart}\n                widget={w}\n                key={w.id}\n              />\n            );\n          }\n\n          if (w.type === \"arrow\") {\n            return <Arrow widget={w} key={w.id} />;\n          }\n\n          return null;\n        })}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}